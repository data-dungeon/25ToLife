


#include "Effects/EffectsPCH.h"

#ifndef PS2

// PAB
//#define USE_VU_IMPLEMENTATION

#if defined (USE_VU_IMPLEMENTATION)

// FILE AUTOMATICALLY GENERATED BY vcl2cpp.pl
//
// cleaned up by Paul Blagay 6/23/03

// Vectors
Vector4 n2,wakelensq,toeye,miptbp2,rgba,mnormadj,tex1,t3,zeros,txi,ll0025,osq,delta,ll004f,timescalec,lnormal,posscale,n1,ll004b,zero,vf00,planesign,rinitval;
Vector4 ll0005,val,ll0077,weighth,ll00bd,physicsheight,ll002c,wakediffsq,ll0069,a,ll0029,totalwakenormal,ll0032,twice,ll0095,oldtex,ll00a4,ll0050,ll004a,mvtxadj;
Vector4 arsq,scalednormal,fi,dota,ll003b,ll008a,tz,onetwothree,wsign3,wakepassscale,ll00dd,ringparams2,cell,ll001c,ptr,fsize,wsign,ringnormal,eye,tex0,o,ll0038,slope1;
Vector4 miptbp1,mx,ll001a,cosout,mscale,affector,ll00ad,screenspace,ll0082,ll0075,ll0011,wakescale,ll0066,ll0065,weightlh,local,pc,ll00a2,ll009c,phynormal;
Vector4 ramppos,wakeradiussq,ll0055,wakedistsq,n3,ll00b7,test,ll00a6,ll0097,wsign2,ll002b,minvscale,ll0015,ll008f,ll00cb,alphascale,mastertz,wakedistscale,mastert;
Vector4 oneminussin,ll000e,eyepart2,ll0093,ring,fdmax,ll00dc,ll005d,ll0051,rampposinit,totalwakescale,acount,ll0054,agediff,t4,vtxxzxz,ll0026,ll00bb,age,ll0099,ll005e;
Vector4 ll004c,gevhalfsize,ll0023,ll00c2,n,scaled,ll001d,ll00d3_vtx_,ar,timescalea,xval,normal,thisringnorm,weighthh,ll00b1,vf0,two,n4,weighthl,screenvtx,dbase,t5,ll0030,dampf,horiznorm,wakediffsqrot,st,weightll;
Vector4 ll0041v,tempv,ll0067,minpt,ll002e,ringparams3,oneminusy,miscqw24,ll0052,acc,fdepthdiff,mt,color,wakenormal,offsetvtx,ll0089,ll001e,tx,maxpt,zval,ll0068,height,wakepair,testvtx,subqword,ll00d7,normalscaled;
Vector4 wakediff,ll00bf,halfsize,timescaleb,ll00c7,ll00ab,ll00db,next_vtx_,b1,ll0074,wsign4,mastertx,normysq,rotlayer,b2,ll00be,ll005c,ll00d5,negones;
Vector4 worldvtx,ll002a,growth,ll0014,wsign0,ll0013,ll00de,ll00d6,gevcell,olensq,twos,ll0053,distance,ll008c,ll0017,ll0031,ringparams1,refl,mz,ll00c6,ll00a9,sum,destvtx,dampval,pr,alpha1,ll000f,signs,ll009e,ll00a0;
Vector4 ll006f,ll00af,twoarpr,t2,clamp,weightl,ll0004,newcell,angle,curr_vtx_,ysq,localspace,ones,ll002d,ll00d0,dot,gcell,ll0021,grid16,ll003a,b0,ll00d8,t6,vertnorm,invradiussq,normbuff,ll0001,canonicalspace,ll006a;
Vector4 ll0073,world,texturespace,t1,f,ll00c8,ll003e,clipspace,cosin,slope0,timescale,tzi,ll0091;

// added by PAB - replaced versions created by perl script
Vector4 mlocaltoclip[4];		
Vector4 mworldtolocal[4];		
Vector4 mcliptoworld[4];		
Vector4 mcliptolocal[4];		
Vector4 mcliptoscreen[4];		
Vector4 mscreentoclip[4];		
Vector4 mtexmatrix[4];	
Vector4 ll0037[4];
Vector4 layerv[6];		
Vector4 valqw[4];		
Vector4 valqw1[4];		
Vector4 noise[2];		
Vector4	spritev[8];
Vector4	rotvec[4];
Vector4	nextvtx;		
Vector4	nexttex[2];		
Vector4	currvtx;		
Vector4	currtex[2];		
Vector4	ll00d3vtx;		
Vector4	ll00d3tex[2];	
Vector4 texv, vtxv;

//shorts
unsigned short ll0079,ll00c9,ll0003,ll0059,ll005b,quad2,buff0,sprite7,ll0056,ll0049,ll00ac,inputptr,ll00ba,sprite4,ll0098,ll000a;
unsigned short motherkickedbuff,ll0046,ll005f,ll00c0,idx,layertype,ll0061,ll00b8,currbuff,wsignbit,ll00c3,clampme;
unsigned short clipflags,ll000d,regcount,ll006b,ll004e,depthdiff,ll0007,ll003c,ll0064,ll0084,ll007d,retaddr,dmax,mkickbufferptr,damp;
unsigned short ll000c,ll0088,sprite2,ll0042,ll00ce,ll0019,ll00cc,numlayers,ll00d2,ll0062,ll00b4,minsubdivdepth,newcount,ll0071,stack,ll0020;
unsigned short ll0060,ll00c5,ll0034,ll0044,ll0086,ll00cf,twofiftyfive,recurse,vi1,maxsubdivdepth,wakescale2,ll003d,mothernormalbuffer;
unsigned short ll0009,buffcount,ll0092,quad1,layer4,maxverts,ll00ca,layer6,ll00c1,numsprites,curclipflg,quad,ll0078,outofview,buff1,ll001f;
unsigned short hasnormal,ll0041,flags0,ll0058,ll007f,layer,ll0085,layerflags,ll0048,affcount,sprite6,ll0076,ll007c,ll0047,ll004d,size,ll006c;
unsigned short sprite,nxtclipflg,ll007b,scissorreturn,ll0043,counter,gevretidx,fifteen,bytemask,ll00a5,ll0063,ll00c4,wsignmask,ll000b,qword;
unsigned short gevretaddr,field,ll0045,ll0033,noptag,depth,ll00cd,ll0035,totalclipflags,layerptr,ll0070,ll00bc,layer2,wakescale1;
unsigned short regnum,ll0057,ll007a,ll007e,ll008b,vtxcount,mnormalbufferptr,ll009f,ll00b9,ll005a,ll0008,ll001b, temp;

// added by PAB - replaced versions created by perl script
unsigned short mkickbuffer[4];
unsigned short work[2];		
unsigned short tex;			
unsigned short vtx;			

float R, Q, I, P;
u32 FC, FS, FM;

//prototypes
static void tolocal_done(Vector4* vumem, short xtop, short xitop);
static void tolocal_nextaffector(Vector4* vumem, short xtop, short xitop);
static void nextcell(Vector4* vumem, short xtop, short xitop);
static void nextquadrant(Vector4* vumem, short xtop, short xitop);
static void drawcomplete(Vector4* vumem, short xtop, short xitop);
static void drawcell(Vector4* vumem, short xtop, short xitop);
static void doesaffectorrequestsubdivision(Vector4* vumem, short xtop, short xitop);
static void endrecursion(Vector4* vumem, short xtop, short xitop);
static void nofinalfan(Vector4* vumem, short xtop, short xitop);
static void generateedgeverts(Vector4* vumem, short xtop, short xitop);
static void dars_positive(Vector4* vumem, short xtop, short xitop);
static void dars_donewiththisone(Vector4* vumem, short xtop, short xitop);
static void dars_done(Vector4* vumem, short xtop, short xitop);
static void dars_negative(Vector4* vumem, short xtop, short xitop);
static void gevreturn2(Vector4* vumem, short xtop, short xitop);
static void gevreturn1(Vector4* vumem, short xtop, short xitop);
static void gevreturn0(Vector4* vumem, short xtop, short xitop);
static void gev_addsimple(Vector4* vumem, short xtop, short xitop);
static void gev_done(Vector4* vumem, short xtop, short xitop);
static void rendermultipass(Vector4* vumem, short xtop, short xitop);
static void dars_nextaffector(Vector4* vumem, short xtop, short xitop);
static void renderfan(Vector4* vumem, short xtop, short xitop);
static void rmp_environmentverts(Vector4* vumem, short xtop, short xitop);
static void rmp_donewithverts(Vector4* vumem, short xtop, short xitop);
static void rmp_specularverts(Vector4* vumem, short xtop, short xitop);
static void rmp_distortverts(Vector4* vumem, short xtop, short xitop);
static void dontrendernormals(Vector4* vumem, short xtop, short xitop);
static void skipit158(Vector4* vumem, short xtop, short xitop);
static void gy_skiprings(Vector4* vumem, short xtop, short xitop);
static void gy_wake_loop(Vector4* vumem, short xtop, short xitop);
static void gy_ring_loop(Vector4* vumem, short xtop, short xitop);
static void returnfromgety(Vector4* vumem, short xtop, short xitop);
static void rmp_distortverts_loop(Vector4* vumem, short xtop, short xitop);
static void rmp_environmentverts_loop(Vector4* vumem, short xtop, short xitop);
static void gy_skipwakes(Vector4* vumem, short xtop, short xitop);
static void addvertex(Vector4* vumem, short xtop, short xitop);
static void gety(Vector4* vumem, short xtop, short xitop);
static void gy_dontmakenormal1(Vector4* vumem, short xtop, short xitop);
static void gy_dontmakenormal2(Vector4* vumem, short xtop, short xitop);
static void gy_skipwakenormal(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus0(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus10(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus15(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus1(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus11(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus16(Vector4* vumem, short xtop, short xitop);
static void gy_field0(Vector4* vumem, short xtop, short xitop);
static void gy_havefields(Vector4* vumem, short xtop, short xitop);
static void gy_field2(Vector4* vumem, short xtop, short xitop);
static void gy_field3(Vector4* vumem, short xtop, short xitop);
static void gy_field3_rotate(Vector4* vumem, short xtop, short xitop);
static void gy_field2_rotate(Vector4* vumem, short xtop, short xitop);
static void gy_skipminus1(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus4(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus9(Vector4* vumem, short xtop, short xitop);
static void gy_skipplus14(Vector4* vumem, short xtop, short xitop);
static void rmp_donewithlayers(Vector4* vumem, short xtop, short xitop);
static void rmp_nextlayer(Vector4* vumem, short xtop, short xitop);
static void rmp_nextbuffer(Vector4* vumem, short xtop, short xitop);
static void rmp_decalverts_loop320(Vector4* vumem, short xtop, short xitop);
static void rf_fadedone330(Vector4* vumem, short xtop, short xitop);
static void rf_fadeedges330(Vector4* vumem, short xtop, short xitop);
static void rmp_singlebuffer(Vector4* vumem, short xtop, short xitop);
static void rmp_donewithlayers(Vector4* vumem, short xtop, short xitop);
static void rmp_nextsprite(Vector4* vumem, short xtop, short xitop);
static void rmp_donebufferhandle(Vector4* vumem, short xtop, short xitop);
static void rmp_donewithsprites(Vector4* vumem, short xtop, short xitop);
static void rmp_nextspritebuffer(Vector4* vumem, short xtop, short xitop);
static void rmp_decalverts_loop372(Vector4* vumem, short xtop, short xitop);
static void rmp_singlespritebuffer(Vector4* vumem, short xtop, short xitop);
static void rmp_donebufferhandlesprite(Vector4* vumem, short xtop, short xitop);
static void assertlt396(Vector4* vumem, short xtop, short xitop);
static void rf_darsrequestscissor(Vector4* vumem, short xtop, short xitop);
static void scissorloop402(Vector4* vumem, short xtop, short xitop);
static void _scissorinterpolationscissor_layer_count(Vector4* vumem, short xtop, short xitop);
static void rf_emptyfan(Vector4* vumem, short xtop, short xitop);
static void scissorloop415(Vector4* vumem, short xtop, short xitop);
static void scissorloop427(Vector4* vumem, short xtop, short xitop);
static void scissorloop440(Vector4* vumem, short xtop, short xitop);
static void scissorloop452(Vector4* vumem, short xtop, short xitop);
static void scissorloop465(Vector4* vumem, short xtop, short xitop);
static void assertlt478(Vector4* vumem, short xtop, short xitop);
static void rf_skipclip(Vector4* vumem, short xtop, short xitop);
static void rf_distortvtx(Vector4* vumem, short xtop, short xitop);
static void rf_nextvtx(Vector4* vumem, short xtop, short xitop);
static void rf_dontrandcolor(Vector4* vumem, short xtop, short xitop);
static void rf_fadedone510(Vector4* vumem, short xtop, short xitop);
static void rf_fadeedges510(Vector4* vumem, short xtop, short xitop);
static void rf_fadedone(Vector4* vumem, short xtop, short xitop);
static void rf_vertsready(Vector4* vumem, short xtop, short xitop);
static void rf_dontrandcolor2(Vector4* vumem, short xtop, short xitop);
static void rf_fadedone526(Vector4* vumem, short xtop, short xitop);
static void rf_fadeedges526(Vector4* vumem, short xtop, short xitop);
static void rf_fadedone2(Vector4* vumem, short xtop, short xitop);
static void rf_nootherbuffer(Vector4* vumem, short xtop, short xitop);
static void curroutside546(Vector4* vumem, short xtop, short xitop);
static void conextout546(Vector4* vumem, short xtop, short xitop);
static void conextin546(Vector4* vumem, short xtop, short xitop);
static void currinside546(Vector4* vumem, short xtop, short xitop);
static void scissorinterpolationend546(Vector4* vumem, short xtop, short xitop);
static void cinextin546(Vector4* vumem, short xtop, short xitop);
static void cinextout546(Vector4* vumem, short xtop, short xitop);



// need to implement this on the other platforms
// send geometry to be rendered
static void XGKICK( Vector4 *vumem, short offset)
{

	bool end;

	do {
		int count = Math::FloatAsInt(vumem[offset].X());
		end = count & 0x8000;
		int skipme = count & 0x80000000;
		count &= 0x7fff;

		// skip the gif tag
		offset++;

		// is this a texture transfer?
		if(skipme)
		{
			offset += count;
			continue;
		}

		for(;count--;)
		{
			Vector4 st = vumem[offset++];
			Vector4 rgba = vumem[offset++];
			Vector4 xyz = vumem[offset++];

			// xyz FTOI4
			// rgba lower 8 bits of each xyzw
			// stq s=s/q t=t/q (0-1)

		}
	}while(!end);

}

static void Clip(Vector4 lhs, Vector4 rhs)
{
	float w = Math::Abs(rhs.W());
	FC = (FC << 6) & 0xFFFFFF;

	if(lhs.X() > w)
		FC |= 0x000001;
   if(lhs.X() < -w)
      FC |= 0x000002;
	if(lhs.Y() > w)
		FC |= 0x000004;
   if(lhs.Y() < -w)
      FC |= 0x000008;
	if(lhs.Z() > w)
		FC |= 0x000010;
   if(lhs.Z() < -w)
      FC |= 0x000020;
}
static void DoFMSETX   (Vector4& dest,  Vector4 val)
{
	dest.X  (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
}
static void DoFMSETXY  (Vector4& dest,  Vector4 val)
{
	dest.XY  (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 2  ;
	t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
}
static void DoFMSETXYZ (Vector4& dest,  Vector4 val)
{
	dest.XYZ (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 2  ;
	t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
}

static void DoFMSETXYW(Vector4& dest,  Vector4 val)
{
	dest.Set (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 2  ;
	t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 1  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}

static void DoFMSETXYZW(Vector4& dest,  Vector4 val)
{
	dest.Set (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 2  ;
	t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSET(Vector4& dest,  Vector4 val)
{
	DoFMSETXYZW(dest, val);
}

static void DoFMSETY   (Vector4& dest,  Vector4 val)
{
	dest.Y   (val);
	FM &= 0x1111 << 2  ;
	float t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
}
static void DoFMSETYZ  (Vector4& dest,  Vector4 val)
{
	dest.YZ  (val);
	FM &= 0x1111 << 2  ;
	float t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
}
static void DoFMSETYZW (Vector4& dest,  Vector4 val)
{
	dest.YZW (val);
	FM &= 0x1111 << 2  ;
	float t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSETZ   (Vector4& dest,  Vector4 val)
{
	dest.Z   (val);
	FM &= 0x1111 << 1  ;
	float t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
}
static void DoFMSETW   (Vector4& dest,  Vector4 val)
{
	dest.W   (val);
	FM &= 0x1111 << 0  ;
	float t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSETZW  (Vector4& dest,  Vector4 val)
{
	dest.ZW  (val);
	FM &= 0x1111 << 1  ;
	float t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSETXZ  (Vector4& dest,  Vector4 val)
{
	dest.XZ  (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
}
static void DoFMSETXZW (Vector4& dest,  Vector4 val)
{
	dest.XZW (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 1  ;
	t = dest.Z();
   if(t == 0.0f) FM |= 0x0001 << 1  ;
	if(t < 0.0f) FM |= 0x0010 << 1  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 1  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 1  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSETXW  (Vector4& dest,  Vector4 val)
{
	dest.XW  (val);
	FM &= 0x1111 << 3  ;
	float t = dest.X();
   if(t == 0.0f) FM |= 0x0001 << 3  ;
	if(t < 0.0f) FM |= 0x0010 << 3  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 3  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 3  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSETYW  (Vector4& dest,  Vector4 val)
{
	dest.YW  (val);
	FM &= 0x1111 << 2  ;
	float t = dest.Y();
   if(t == 0.0f) FM |= 0x0001 << 2  ;
	if(t < 0.0f) FM |= 0x0010 << 2  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 2  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 2  ;
	FM &= 0x1111 << 0  ;
	t = dest.W();
   if(t == 0.0f) FM |= 0x0001 << 0  ;
	if(t < 0.0f) FM |= 0x0010 << 0  ;
	if(t == Math::NegativeInfinity) FM |= 0x0100 << 0  ;
	if(t == Math::PositiveInfinity) FM |= 0x1000 << 0  ;
}
static void DoFMSET(Vector4& dest,  float val)
{
	DoFMSETXYZW(dest, Vector4(val,val,val,val));
}
static void DoFMSETX(Vector4& dest,  float val)
{
	DoFMSETX(dest, Vector4(val,val,val,val));
}
static void DoFMSETY(Vector4& dest,  float val)
{
	DoFMSETY(dest, Vector4(val,val,val,val));
}
static void DoFMSETZ(Vector4& dest,  float val)
{
	DoFMSETZ(dest, Vector4(val,val,val,val));
}
static void DoFMSETW(Vector4& dest,  float val)
{
	DoFMSETW(dest, Vector4(val,val,val,val));
}

//////////////////////////////////////////////////
// VU CODE ENTRY POINT
//////////////////////////////////////////////////

// See page 10 of printout  waterps2.vcl
void     Water_VCL(Vector4* vumem, short xtop, short xitop)
{
	vf0.Set(0.0f, 0.0f, 0.0f, 1.0f);
	R = Math::IntAsFloat(0x78000000);
	// ### 	.init_vf_all
	// ### 	.init_vi_all
	// ### 	.name Water
	// ### 	fcset			0x000000
	FC = 0x000000;
	// ### 	lq.xyzw mScale, 0(vi00)
	mscale.Set(vumem[0 + 0]);
	// ### 	lq    mLocalToClip[0], 5+0(vi00)
	mlocaltoclip[0].Set(vumem[5+0 + 0]);
	// ### 	lq    mLocalToClip[1], 5+1(vi00)
	mlocaltoclip[1].Set(vumem[5+1 + 0]);
	// ### 	lq    mLocalToClip[2], 5+2(vi00)
	mlocaltoclip[2].Set(vumem[5+2 + 0]);
	// ### 	lq		mLocalToClip[3], 5+3(vi00)
	mlocaltoclip[3].Set(vumem[5+3 + 0]);
	// ### 	iaddiu				Stack,	vi00,					317
	stack = 0 + (unsigned)317;
	// ### 	max.xyzw				ones,	   vf00,				vf00[w]
	ones.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	loi			615651.564651651
	I = 615651.564651651f;
	// ### 	add			rinitval,			vf00,						I
	DoFMSET(rinitval, vf0 + I);
	// ### 	rinit			R,						rinitval[x]
	R = Math::IntAsFloat((Math::FloatAsInt(rinitval.X()) & 0x007FFFFF) | 0x78000000);			// intasfloat??
	// ### 	div			Q,						vf00[w],					mScale[x]
	Q = 1.0f / mscale.X();
	// ### 	addq.x		mInvScale,			vf00,						Q
	DoFMSETX(minvscale, Q);
	// ### 	div			Q,						vf00[w],					mScale[z]
	Q = 1.0f / mscale.Z();
	// ### 	addq.z		mInvScale,			vf00,						Q
	DoFMSETZ(minvscale, Q);
	// ### 	iaddiu				noptag,	vi00,					0x7fff
	noptag = 0 + (unsigned)0x7fff;
	// ### 	iaddiu		noptag,				noptag,					1
	noptag = noptag + (unsigned)1;
	// ### 	mfir.x	 LL0001, noptag
	ll0001.X(Math::IntAsFloat(noptag));
	// ### 	mfir.y	 LL0001, vi00
	ll0001.Y(0.0f);
	// ### 	mfir.z	 LL0001, vi00
	ll0001.Z(0.0f);
	// ### 	mfir.w	 LL0001, vi00
	ll0001.W(0.0f);
	// ### 	sq.xyzw LL0001, 317(vi00)
	vumem[317 + 0].Set(ll0001);
	// ### 	iaddiu				buff0,	vi00,					897
	buff0 = 0 + (unsigned)897;
	// ### 	iaddiu				buff1,	vi00,					961
	buff1 = 0 + (unsigned)961;
	// ### 	mfir.x		normbuff,			buff0
	normbuff.X(Math::IntAsFloat(buff0));
	// ### 	mfir.y		normbuff,			buff1
	normbuff.Y(Math::IntAsFloat(buff1));
	// ### 	sq.xy			normbuff,			318(vi00)		:	318
	vumem[318 + 0].XY(normbuff);
	// ### 	mini.xyzw			zero,		vf00,				vf00[x]
	zero.Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	sub.xyzw				negones,	  zero,	 vf00[w]
	DoFMSETXYZW(negones, zero - 1.0f);
	// ### 	mini.xyzw			zeros,		vf00,				vf00[x]
	zeros.Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	sq.y			zeros,				265+0(vi00)
	vumem[265+0 + 0].Y(zeros);
	// ### 	sq.xzw		negones,				265+0(vi00)
	vumem[265+0 + 0].XZW(negones);
	// ### 	sq.x			ones,					265+1(vi00)
	vumem[265+1 + 0].X(ones);
	// ### 	sq.y			zeros,				265+1(vi00)
	vumem[265+1 + 0].Y(zeros);
	// ### 	sq.zw			negones,				265+1(vi00)
	vumem[265+1 + 0].ZW(negones);
	// ### 	sq.z			ones,					265+2(vi00)
	vumem[265+2 + 0].Z(ones);
	// ### 	sq.y			zeros,				265+2(vi00)
	vumem[265+2 + 0].Y(zeros);
	// ### 	sq.xw			negones,				265+2(vi00)
	vumem[265+2 + 0].XW(negones);
	// ### 	sq.xz			ones,					265+3(vi00)
	vumem[265+3 + 0].XZ(ones);
	// ### 	sq.y			zeros,				265+3(vi00)
	vumem[265+3 + 0].Y(zeros);
	// ### 	sq.w			negones,				265+3(vi00)
	vumem[265+3 + 0].W(negones);
	// ### 	lq.w			acount,				128(vi00)	:128
	acount.W(vumem[128 + 0]);
	// ### 	mtir			affcount,			acount[w]
	affcount = (unsigned short)Math::FloatAsInt(acount.W());
	// ### 	iaddiu				bytemask,	vi00,					0xFF
	bytemask = 0 + (unsigned)0xff;
	// ### 	iand			affcount,			affcount,				bytemask
	affcount = affcount & bytemask;
	// ### 	ibeq					affcount,		vi00,					ToLocal_Done
	if(affcount == 0) 
	{ 
	//pab	tolocal_done(vumem,xtop,xitop); 

		// BLOCK added PAB
		mkickbuffer[0] = 0 + (unsigned)321;
		// ### 	iaddiu				mKickBuffer[1],	vi00,					513
		mkickbuffer[1] = 0 + (unsigned)513;
		// ### 	iaddiu				mKickBuffer[2],	vi00,					705
		mkickbuffer[2] = 0 + (unsigned)705;
		// ### 	loi			0.5
		I = 0.5;
		// ### 	max.xyzw				cell,	   vf00,				vf00[w]
		cell.Set(1.0f, 1.0f, 1.0f, 1.0f);
		// ### 	mini.y			cell,	   vf00,				vf00[x]
		cell.Y(0.0f);
		// ### 	mul			cell,					cell,						I
		DoFMSET(cell, cell * I);
		// ### 	iaddiu				depth,	vi00,					0
		depth = 0 + (unsigned)0;
		// ### NextCell:
		nextcell(vumem,xtop,xitop);

		return; 
	}
	// ### 	lq    mWorldToLocal[0], 13+0(vi00)
	mworldtolocal[0].Set(vumem[13+0 + 0]);
	// ### 	lq    mWorldToLocal[1], 13+1(vi00)
	mworldtolocal[1].Set(vumem[13+1 + 0]);
	// ### 	lq    mWorldToLocal[2], 13+2(vi00)
	mworldtolocal[2].Set(vumem[13+2 + 0]);
	// ### 	lq		mWorldToLocal[3], 13+3(vi00)
	mworldtolocal[3].Set(vumem[13+3 + 0]);
	// ### ToLocal_NextAffector:
//	tolocal_nextaffector(vumem,xtop,xitop);
//}
//static void tolocal_nextaffector(Vector4* vumem, short xtop, short xitop)
//{
//	// ### 	isubiu				affcount,	affcount,				1
//	affcount = affcount - (unsigned)1;
for(;affcount--;)
{
	// ### 	lq				affector,			128(affcount)	:128
	affector.Set(vumem[128 + affcount]);
	// ### 	mini.yw			world,	   vf00,				vf00[x]
//	world.YW(Vector4::Min(vf0, 0.0f));
	world.YW(0.0f,0.0f);
	// ### 	move.xz		world,				affector
	world.XZ(affector);
	// ### 	add			 		acc,        mWorldToLocal[3], 	VF00[x]
	DoFMSET(acc, mworldtolocal[3] + 0.0f);
	// ### 	madd         		acc,        mWorldToLocal[0], 	world[x]
	DoFMSET(acc, acc + mworldtolocal[0] * world.X());
	// ### 	madd         		acc,        mWorldToLocal[1],		world[y]
	DoFMSET(acc, acc + mworldtolocal[1] * world.Y());
	// ### 	madd.xyz     		local, 	mWorldToLocal[2],		world[z]
	DoFMSETXYZ(local, acc + mworldtolocal[2] * world.Z());
	// ### 	move.yw		local,				affector
	local.YW(affector);
	// ### 	sq				local,				128(affcount)	:128
	vumem[128 + affcount].Set(local);
	// ### 	ibgtz			affcount,			ToLocal_NextAffector	
//	if(affcount > 0) 
//	{ 
//		tolocal_nextaffector(vumem,xtop,xitop); 
//		return; 
//	}
}
	// ### ToLocal_Done:
//	tolocal_done(vumem,xtop,xitop);
//}
//static void tolocal_done(Vector4* vumem, short xtop, short xitop)
//{
	// ### 	iaddiu				mKickBuffer[0],	vi00,					321
	mkickbuffer[0] = 0 + (unsigned)321;
	// ### 	iaddiu				mKickBuffer[1],	vi00,					513
	mkickbuffer[1] = 0 + (unsigned)513;
	// ### 	iaddiu				mKickBuffer[2],	vi00,					705
	mkickbuffer[2] = 0 + (unsigned)705;
	// ### 	loi			0.5
	I = 0.5;
	// ### 	max.xyzw				cell,	   vf00,				vf00[w]
	cell.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	mini.y			cell,	   vf00,				vf00[x]
	cell.Y(0.0f);
	// ### 	mul			cell,					cell,						I
	DoFMSET(cell, cell * I);
	// ### 	iaddiu				depth,	vi00,					0
	depth = 0 + (unsigned)0;
	// ### NextCell:
	nextcell(vumem,xtop,xitop);
}
static void nextcell(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				depth,	depth,				1
	depth = depth + (unsigned)1;
	// ### 	loi			0.5
	I = 0.5;
	// ### 	mul			halfsize,			ones,						cell[w]
	DoFMSET(halfsize, ones * cell.W());
	// ### 	mul			halfsize,			halfsize,				I
	DoFMSET(halfsize, halfsize * I);
	// ### 	iaddiu				quad,	vi00,					0
	quad = 0 + (unsigned)0;
	// ### NextQuadrant:
	//nextquadrant(vumem,xtop,xitop);
//}
//static void nextquadrant(Vector4* vumem, short xtop, short xitop)
//{

	// ### 	lq				signs,				265(quad)
	signs.Set(vumem[265 + quad]);
	// ### 	mul			temp,					halfsize,				signs
	DoFMSET(tempv, halfsize.Diag(signs));
	// ### 	add			newcell,				temp,						cell
	DoFMSET(newcell, tempv + cell);
	// ### 	iaddiu				depth,	depth,				1
	depth = depth + (unsigned)1;
	// ### 	bal			retaddr,				DoesAffectorRequestSubdivision
	doesaffectorrequestsubdivision(vumem,xtop,xitop);
	// ### 	isubiu				depth,	depth,				1
	depth = depth - (unsigned)1;
	// ### 	ilw.z			outOfView,			318(vi00)
	outofview = Math::FloatAsInt(vumem[318 + 0].z());
	// ### 	isubiu				LL0003,			outOfView,			1
	ll0003 = outofview - (unsigned)1;
	// ### 	ibeq					LL0003,			vi00,				DrawComplete
	if(ll0003 == 0)
	{ 
		drawcomplete(vumem,xtop,xitop);
		return; 
	}
	// ### 	ibeq					recurse,		vi00,					DrawCell
	if(recurse == 0) 
	{ 
		drawcell(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mfir.x	 LL0004, quad
	ll0004.X(Math::IntAsFloat(quad));
	// ### 	sqd.x LL0004, (--Stack)
	vumem[--stack].X(ll0004);
	// ### 	sqd.xyzw			cell, (--Stack)
	vumem[--stack].Set(cell);
	// ### 	sqd.xyzw			halfsize, (--Stack)
	vumem[--stack].Set(halfsize);
	// ### 	move			cell,					newcell
	cell.Set(newcell);
	// ### 	b				NextCell
	nextcell(vumem,xtop,xitop);
	return;
}
static void endrecursion(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lqi.xyzw			halfsize, (Stack++)
	halfsize.Set(vumem[stack++]);
	// ### 	lqi.xyzw			cell, (Stack++)
	cell.Set(vumem[stack++]);
	// ### 	lqi.xyzw LL0005, (Stack++)
	ll0005.Set(vumem[stack++]);
	// ### 	mtir	 quad, LL0005[x]
	quad = (unsigned short)Math::FloatAsInt(ll0005.X());
	// ### DrawComplete:
	drawcomplete(vumem,xtop,xitop);
}
static void drawcomplete(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				quad,	quad,				1
	quad = quad + (unsigned)1;
	// ### 	isubiu				LL0007,			quad,			4
	ll0007 = quad - (unsigned)4;
	// ### 	ibne					LL0007,			vi00,				NextQuadrant
	if(ll0007 != 0) 
	{ 
			// ### 	lq				signs,				265(quad)
	signs.Set(vumem[265 + quad]);
	// ### 	mul			temp,					halfsize,				signs
	DoFMSET(tempv, halfsize.Diag(signs));
	// ### 	add			newcell,				temp,						cell
	DoFMSET(newcell, tempv + cell);
	// ### 	iaddiu				depth,	depth,				1
	depth = depth + (unsigned)1;
	// ### 	bal			retaddr,				DoesAffectorRequestSubdivision
	doesaffectorrequestsubdivision(vumem,xtop,xitop);
	// ### 	isubiu				depth,	depth,				1
	depth = depth - (unsigned)1;
	// ### 	ilw.z			outOfView,			318(vi00)
	outofview = Math::FloatAsInt(vumem[318 + 0].z());
	// ### 	isubiu				LL0003,			outOfView,			1
	ll0003 = outofview - (unsigned)1;
	// ### 	ibeq					LL0003,			vi00,				DrawComplete
	if(ll0003 == 0)
	{ 
		drawcomplete(vumem,xtop,xitop);
		return; 
	}
	// ### 	ibeq					recurse,		vi00,					DrawCell
	if(recurse == 0) 
	{ 
		drawcell(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mfir.x	 LL0004, quad
	ll0004.X(Math::IntAsFloat(quad));
	// ### 	sqd.x LL0004, (--Stack)
	vumem[--stack].X(ll0004);
	// ### 	sqd.xyzw			cell, (--Stack)
	vumem[--stack].Set(cell);
	// ### 	sqd.xyzw			halfsize, (--Stack)
	vumem[--stack].Set(halfsize);
	// ### 	move			cell,					newcell
	cell.Set(newcell);
	// ### 	b				NextCell
	nextcell(vumem,xtop,xitop);
	return;

//		nextquadrant(vumem,xtop,xitop); 
//		return; 
	}
	// ### 	isubiu				depth,	depth,				1
	depth = depth - (unsigned)1;
	// ### 	ibgtz			depth,				EndRecursion
	if(depth > 0) 
	{ 
		endrecursion(vumem,xtop,xitop); 
		return;
	}
	// ### 	ilw.w			mKickBuffer[1],	317(vi00)
	mkickbuffer[1] = Math::FloatAsInt(vumem[317 + 0].W());
	// ### 	ibeq					mKickBuffer[1],		vi00,					NoFinalFan
	if(mkickbuffer[1] == 0) 
	{ 
		nofinalfan(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### 	iaddiu				buffcount,	vi00,					1
	buffcount = 0 + (unsigned)1;
	// ### 	bal			retaddr,				RenderMultiPass
	rendermultipass(vumem,xtop,xitop);
	// ### NoFinalFan:
	nofinalfan(vumem,xtop,xitop);
}
static void nofinalfan(Vector4* vumem, short xtop, short xitop)
{
	// ### GenerateEdgeVerts:
	generateedgeverts(vumem,xtop,xitop);
}
static void generateedgeverts(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				depth,	depth,				1
	depth = depth + (unsigned)1;
	// ### 	iaddiu				LL0009,	vi00,					0x00AA
	ll0009 = 0 + (unsigned)0x00aa;
	// ### 	sub.xz			vf00,		gevcell,	vf00[w]
	DoFMSETXZ(vf0, gevcell - 1.0f);
	// ### 	fmand					LL0008,		LL0009
	ll0008 = FM & ll0009;
	// ### 	iadd					LL000a,		LL0008,		LL0008
	ll000a = ll0008 + (unsigned)ll0008;
	// ### 	iadd					LL000a,		LL000a,		LL000a
	ll000a = ll000a + (unsigned)ll000a;
	// ### 	iadd					LL000a,		LL000a,		LL000a
	ll000a = ll000a + (unsigned)ll000a;
	// ### 	iadd					LL000a,		LL000a,		LL000a
	ll000a = ll000a + (unsigned)ll000a;
	// ### 	ior					LL0008,		LL0008,		LL000a
	ll0008 = ll0008 | ll000a;
	// ### 	iaddiu				LL0009,	vi00,					0x00A0
	ll0009 = 0 + (unsigned)0x00a0;
	// ### 	iand					LL0008,		LL0008,		LL0009
	ll0008 = ll0008 & ll0009;
	// ### 	ibne					LL0008,		LL0009,	GEV_AddSimple
	if(ll0008 != ll0009)
	{ 
		gev_addsimple(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				LL000c,	vi00,					0x00AA
	ll000c = 0 + (unsigned)0x00aa;
	// ### 	sub.xz			vf00,		gevcell,	vf00[x]
	DoFMSETXZ(vf0, gevcell - 0.0f);
	// ### 	fmand					LL000b,		LL000c
	ll000b = FM & ll000c;
	// ### 	iadd					LL000d,		LL000b,		LL000b
	ll000d = ll000b + (unsigned)ll000b;
	// ### 	iadd					LL000d,		LL000d,		LL000d
	ll000d = ll000d + (unsigned)ll000d;
	// ### 	iadd					LL000d,		LL000d,		LL000d
	ll000d = ll000d + (unsigned)ll000d;
	// ### 	iadd					LL000d,		LL000d,		LL000d
	ll000d = ll000d + (unsigned)ll000d;
	// ### 	isub					LL000d,		vi00,		LL000d
	ll000d = 0 - (unsigned)ll000d;
	// ### 	isubiu				LL000d,		LL000d,		1
	ll000d = ll000d - (unsigned)1;
	// ### 	iand					LL000b,		LL000b,		LL000d
	ll000b = ll000b & ll000d;
	// ### 	iaddiu				LL000c,	vi00,					0x00A0
	ll000c = 0 + (unsigned)0x00a0;
	// ### 	iand					LL000b,		LL000b,		LL000c
	ll000b = ll000b & ll000c;
	// ### 	ibne					LL000b,		vi00,					GEV_AddSimple
	if(ll000b != 0)
	{ 
		gev_addsimple(vumem,xtop,xitop); 
		return; 
	}
	// ### 	move			gcell,				newcell
	gcell.Set(newcell);
	// ### 	move			newcell,				gevcell
	newcell.Set(gevcell);
	// ### 	bal			retaddr,				DoesAffectorRequestSubdivision
	doesaffectorrequestsubdivision(vumem,xtop,xitop);
	// ### 	move			newcell,				gcell
	newcell.Set(gcell);
	// ### 	ibeq					recurse,		vi00,					GEV_AddSimple
	if(recurse == 0) 
	{ 
		gev_addsimple(vumem,xtop,xitop); 
		return;
	}
	// ### 	sqd.xyzw			gevcell, (--Stack)
	vumem[--stack].Set(gevcell);
	// ### 	mfir.x	 LL000e, gevretidx
	ll000e.X(Math::IntAsFloat(gevretidx));
	// ### 	sqd.x LL000e, (--Stack)
	vumem[--stack].X(ll000e);
	// ### 	loi			0.5
	I = 0.5;
	// ### 	mul			gevhalfsize,		ones,						gevcell[w]
	DoFMSET(gevhalfsize, ones * gevcell.W());
	// ### 	mul			gevhalfsize,		gevhalfsize,			I
	DoFMSET(gevhalfsize, gevhalfsize * I);
	// ### 	lq				signs,				265(quad1)
	signs.Set(vumem[265 + quad1]);
	// ### 	mul			temp,					gevhalfsize,			signs
	DoFMSET(tempv, gevhalfsize.Diag(signs));
	// ### 	add			gevcell,				temp,						gevcell
	DoFMSET(gevcell, tempv + gevcell);
	// ### 	iaddiu				gevretidx,	vi00,					1
	gevretidx = 0 + (unsigned)1;
	// ### 	b				GenerateEdgeVerts

	//?? PAB
	generateedgeverts(vumem,xtop,xitop);
	return;
}
static void gevreturn1(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lqi.xyzw LL000f, (Stack++)
	ll000f.Set(vumem[stack++]);
	// ### 	mtir	 gevretidx, LL000f[x]
	gevretidx = (unsigned short)Math::FloatAsInt(ll000f.X());
	// ### 	lqi.xyzw			gevcell, (Stack++)
	gevcell.Set(vumem[stack++]);
	// ### 	isubiu				Stack,	Stack,				2
	stack = stack - (unsigned)2;
	// ### 	loi			0.5
	I = 0.5;
	// ### 	mul			gevhalfsize,		ones,						gevcell[w]
	DoFMSET(gevhalfsize, ones * gevcell.W());
	// ### 	mul			gevhalfsize,		gevhalfsize,			I
	DoFMSET(gevhalfsize, gevhalfsize * I);
	// ### 	lq				signs,				265(quad2)
	signs.Set(vumem[265 + quad2]);
	// ### 	mul			temp,					gevhalfsize,			signs
	DoFMSET(tempv, gevhalfsize.Diag(signs));
	// ### 	add			gevcell,				temp,						gevcell
	DoFMSET(gevcell, tempv + gevcell);
	// ### 	iaddiu				gevretidx,	vi00,					2
	gevretidx = 0 + (unsigned)2;
	// ### 	b				GenerateEdgeVerts

	//?? PAB
	generateedgeverts(vumem,xtop,xitop);
	return;

}
static void gevreturn2(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lqi.xyzw LL0011, (Stack++)
	ll0011.Set(vumem[stack++]);
	// ### 	mtir	 gevretidx, LL0011[x]
	gevretidx = (unsigned short)Math::FloatAsInt(ll0011.X());
	// ### 	lqi.xyzw			gevcell, (Stack++)
	gevcell.Set(vumem[stack++]);
	// ### 	b				GEV_Done

	// gev_done
		// ### 	isubiu				depth,	depth,				1
	depth = depth - (unsigned)1;
	// ### 	ibeq					gevretidx,		vi00,					GEVReturn0
	if(gevretidx == 0) 
	{ 
//		gevreturn0(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isubiu				gevretidx,	gevretidx,				1
	gevretidx = gevretidx - (unsigned)1;
	// ### 	ibeq					gevretidx,		vi00,					GEVReturn1
	if(gevretidx == 0) 
	{ 
		gevreturn1(vumem,xtop,xitop); 
		return; 
	}
	// ### 	b				GEVReturn2

	//?? PAB
	gevreturn2(vumem,xtop,xitop);
	return;

//	gev_done(vumem,xtop,xitop);
//	return;

}
static void gevreturn0(Vector4* vumem, short xtop, short xitop)
{
	// ### 	jr				gevretaddr
	return;
}
static void gev_addsimple(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				signs,				265(quad2)
	signs.Set(vumem[265 + quad2]);
	// ### 	mul			temp,					signs,					gevcell[w]
	DoFMSET(tempv, signs * gevcell.W());
	// ### 	add			vtx,					temp,						gevcell
	DoFMSET(vtxv, tempv + gevcell);
	// ### 	mfir.x	 LL0013, depth
	ll0013.X(Math::IntAsFloat(depth));
	// ### 	mfir.y	 LL0013, gevretidx
	ll0013.Y(Math::IntAsFloat(gevretidx));
	// ### 	mfir.z	 LL0013, quad1
	ll0013.Z(Math::IntAsFloat(quad1));
	// ### 	mfir.w	 LL0013, quad2
	ll0013.W(Math::IntAsFloat(quad2));
	// ### 	sqd.xyzw LL0013, (--Stack)
	vumem[--stack].Set(ll0013);
	// ### 	mfir.x	 LL0014, quad
	ll0014.X(Math::IntAsFloat(quad));
	// ### 	sqd.x LL0014, (--Stack)
	vumem[--stack].X(ll0014);
	// ### 	sqd.xyzw			gevcell, (--Stack)
	vumem[--stack].Set(gevcell);
	// ### 	sqd.xyzw			halfsize, (--Stack)
	vumem[--stack].Set(halfsize);
	// ### 	bal			retaddr,				AddVertex
	addvertex(vumem,xtop,xitop);
	// ### 	lqi.xyzw			halfsize, (Stack++)
	halfsize.Set(vumem[stack++]);
	// ### 	lqi.xyzw			gevcell, (Stack++)
	gevcell.Set(vumem[stack++]);
	// ### 	lqi.xyzw LL0015, (Stack++)
	ll0015.Set(vumem[stack++]);
	// ### 	mtir	 quad, LL0015[x]
	quad = (unsigned short)Math::FloatAsInt(ll0015.X());
	// ### 	lqi.xyzw LL0017, (Stack++)
	ll0017.Set(vumem[stack++]);
	// ### 	mtir	 depth, LL0017[x]
	depth = (unsigned short)Math::FloatAsInt(ll0017.X());
	// ### 	mtir	 gevretidx, LL0017[y]
	gevretidx = (unsigned short)Math::FloatAsInt(ll0017.Y());
	// ### 	mtir	 quad1, LL0017[z]
	quad1 = (unsigned short)Math::FloatAsInt(ll0017.Z());
	// ### 	mtir	 quad2, LL0017[w]
	quad2 = (unsigned short)Math::FloatAsInt(ll0017.W());
	// ### GEV_Done:
//	gev_done(vumem,xtop,xitop);
//}
//static void gev_done(Vector4* vumem, short xtop, short xitop)
//{
	// ### 	isubiu				depth,	depth,				1
	depth = depth - (unsigned)1;
	// ### 	ibeq					gevretidx,		vi00,					GEVReturn0
	if(gevretidx == 0) 
	{ 
//		gevreturn0(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isubiu				gevretidx,	gevretidx,				1
	gevretidx = gevretidx - (unsigned)1;
	// ### 	ibeq					gevretidx,		vi00,					GEVReturn1
	if(gevretidx == 0) 
	{ 
		gevreturn1(vumem,xtop,xitop); 
		return; 
	}
	// ### 	b				GEVReturn2

	//?? PAB
	gevreturn2(vumem,xtop,xitop);
	return;

}

static void doesaffectorrequestsubdivision(Vector4* vumem, short xtop, short xitop)
{
	// ### 	sub			minpt,				newcell,					newcell[w]
	DoFMSET(minpt, newcell - newcell.W());
	// ### 	add			maxpt,				newcell,					newcell[w]
	DoFMSET(maxpt, newcell + newcell.W());
	// ### 	ilw.w			maxSubDivDepth,	0(vi00)
	maxsubdivdepth = Math::FloatAsInt(vumem[0 + 0].w());
	// ### 	iaddiu				bytemask,	vi00,					0xFF
	bytemask = 0 + (unsigned)0xff;
	// ### 	iand			maxSubDivDepth,	maxSubDivDepth,		bytemask
	maxsubdivdepth = maxsubdivdepth & bytemask;
	// ### 	ibeq			depth,				maxSubDivDepth,		DARS_Negative
	if(depth == maxsubdivdepth) 
	{ 
		dars_negative(vumem,xtop,xitop); 
		return; 
	}
	// ### 	ilw.z			minSubDivDepth,	0(vi00)
	minsubdivdepth = Math::FloatAsInt(vumem[0 + 0].z());
	// ### 	iand			minSubDivDepth,	minSubDivDepth,		bytemask
	minsubdivdepth = minsubdivdepth & bytemask;
	// ### 	isub					LL0019,			depth,			minSubDivDepth
	ll0019 = depth - (unsigned)minsubdivdepth;
	// ### 	ibltz					LL0019,			DARS_Positive
	if(ll0019 < 0) 
	{ 
		dars_positive(vumem,xtop,xitop);
		return; 
	}
	// ### 	lq.w			acount,				128(vi00)	:128
	acount.W(vumem[128 + 0]);
	// ### 	mtir			affcount,			acount[w]
	affcount = (unsigned short)Math::FloatAsInt(acount.W());
	// ### 	iand			affcount,			affcount,				bytemask
	affcount = affcount & bytemask;
	// ### 	ibeq					affcount,		vi00,					DARS_Negative
	if(affcount == 0) 
	{ 
		dars_negative(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mul.xz		minpt,				minpt,					mScale
	DoFMSETXZ(minpt, minpt.Diag(mscale));
	// ### 	mul.xz		maxpt,				maxpt,					mScale
	DoFMSETXZ(maxpt, maxpt.Diag(mscale));
	// ### 	mfir.x	 LL001a, mKickBuffer[0]
	ll001a.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL001a, mKickBuffer[1]
	ll001a.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	mfir.z	 LL001a, mKickBuffer[2]
	ll001a.Z(Math::IntAsFloat(mkickbuffer[2]));
	// ### 	sqd.xyz LL001a, (--Stack)
	vumem[--stack].XYZ(ll001a);
	// ### DARS_NextAffector:
	dars_nextaffector(vumem,xtop,xitop);
}

static void dars_nextaffector(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				affcount,	affcount,				1
	affcount = affcount - (unsigned)1;
	// ### 	lq				affector,			128(affcount)	:128
	affector.Set(vumem[128 + affcount]);
	// ### 	mtir			dmax,					affector[y]
	dmax = (unsigned short)Math::FloatAsInt(affector.Y());
	// ### 	iand			dmax,					dmax,						bytemask
	dmax = dmax & bytemask;
	// ### 	isub					LL001b,			dmax,			depth
	ll001b = dmax - (unsigned)depth;
	// ### 	ibltz					LL001b,			DARS_DoneWithThisOne
	if(ll001b < 0) 
	{ 
		dars_donewiththisone(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isub			depthdiff,			dmax,						depth
	depthdiff = dmax - (unsigned)depth;
	// ### 	mfir.x		fdepthdiff,			depthdiff
	fdepthdiff.X(Math::IntAsFloat(depthdiff));
	// ### 	mfir.x		fdmax,				dmax
	fdmax.X(Math::IntAsFloat(dmax));
	// ### 	itof0.x		fdepthdiff,			fdepthdiff
	fdepthdiff.X((float)Math::FloatAsInt(fdepthdiff.x())/(1<<0));
	// ### 	itof0.x		fdmax,				fdmax
	fdmax.X((float)Math::FloatAsInt(fdmax.x())/(1<<0));
	// ### 	div			Q,						fdepthdiff[x],			fdmax[x]
	Q = fdepthdiff.X() / fdmax.X();
	// ### 	loi			1.0
	I = 1.0;
	// ### 	mul.y			affector,			affector,				I
	DoFMSETY(affector, affector * I);
	// ### 	loi			3.0
	I = 3.0;
	// ### 	mul.w			affector,			affector,				I
	DoFMSETW(affector, affector * I);
	// ### 	sub.w			Ar,					affector,				affector[y]
	DoFMSETW(ar, affector - affector.Y());
	// ### 	mul.w			ACC,					vf00,						affector[y]
	DoFMSETW(acc, vf0 * affector.Y());
	// ### 	madd.w		Ar,					Ar,						Q
	DoFMSETW(ar, acc + ar * Q);
	// ### 	add			Pc,					minpt,					maxpt
	DoFMSET(pc, minpt + maxpt);
	// ### 	loi			0.5
	I = 0.5;
	// ### 	mul			Pc,					Pc,						I
	DoFMSET(pc, pc * I);
	// ### 	sub			Pr,					maxpt,					minpt
	DoFMSET(pr, maxpt - minpt);
	// ### 	mul					LL001e,		Pr,				Pr
	DoFMSET(ll001e, pr.Diag(pr));
	// ### 	max.xyzw				LL001c,	   vf00,				vf00[w]
	ll001c.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL001e[x]
	DoFMSET(acc, vf0 + ll001e.X());
	// ### 	madd					ACC,			LL001c,				LL001e[y]
	DoFMSET(acc, acc + ll001c * ll001e.Y());
	// ### 	madd					LL001d,			LL001c,				LL001e[z]
	DoFMSET(ll001d, acc + ll001c * ll001e.Z());
	// ### 	sqrt					Q,				LL001d[x]
	Q = Math::Sqrt(ll001d.X());
	// ### 	add.x			Pr,					vf00,						Q
	DoFMSETX(pr, + Q);
	// ### 	mul.x			Pr,					Pr,						I
	DoFMSETX(pr, pr * I);
	// ### 	mul.xz		affector,			affector,				mScale
	DoFMSETXZ(affector, affector.Diag(mscale));
	// ### 	sub			O,						affector,				Pc
	DoFMSET(o, affector - pc);
	// ### 	mul.w			Arsq,					Ar,						Ar
	DoFMSETW(arsq, ar.Diag(ar));
	// ### 	loi			2.0
	I = 2.0;
	// ### 	mul.x			twoArPr,				Pr,						Ar[w]
	DoFMSETX(twoarpr, pr * ar.W());
	// ### 	mul.x			ACC,					twoArPr,					I
	DoFMSETX(acc, twoarpr * I);
	// ### 	madd.x		ACC,					Pr,						Pr
	DoFMSETX(acc, acc + pr.Diag(pr));
	// ### 	madd.x		sum,					ones,						Arsq[w]
	DoFMSETX(sum, acc + ones * arsq.W());
	// ### 	mul.xz		Osq,					O,							O
	DoFMSETXZ(osq, o.Diag(o));
	// ### 	add.x			Olensq,				Osq,						Osq[z]
	DoFMSETX(olensq, osq + osq.Z());
	// ### 	iaddiu				LL0020,	vi00,					0x0088
	ll0020 = 0 + (unsigned)0x0088;
	// ### 	sub.x			vf00,		Olensq,	sum
	DoFMSETX(vf0, olensq - sum);
	// ### 	fmand					LL001f,		LL0020
	ll001f = FM & ll0020;
	// ### 	ibeq					LL001f,		vi00,					DARS_DoneWithThisOne
	if(ll001f == 0) 
	{ 
		dars_donewiththisone(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lqi.xyzw LL0021, (Stack++)
	ll0021.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[0], LL0021[x]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll0021.X());
	// ### 	mtir	 mKickBuffer[1], LL0021[y]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll0021.Y());
	// ### 	mtir	 mKickBuffer[2], LL0021[z]
	mkickbuffer[2] = (unsigned short)Math::FloatAsInt(ll0021.Z());
	// ### DARS_Positive:
	dars_positive(vumem,xtop,xitop);
}

static void dars_positive(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				recurse,	vi00,					1
	recurse = 0 + (unsigned)1;
	// ### 	jr				retaddr
	return;
	// ### DARS_DoneWithThisOne:
	dars_donewiththisone(vumem,xtop,xitop);
}
static void dars_donewiththisone(Vector4* vumem, short xtop, short xitop)
{
	// ### 	ibgtz			affcount,			DARS_NextAffector
	if(affcount > 0) 
	{ 
		dars_nextaffector(vumem,xtop,xitop);
		return; 
	}
	// ### DARS_Done:
	dars_done(vumem,xtop,xitop);
}
static void dars_done(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lqi.xyzw LL0023, (Stack++)
	ll0023.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[0], LL0023[x]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll0023.X());
	// ### 	mtir	 mKickBuffer[1], LL0023[y]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll0023.Y());
	// ### 	mtir	 mKickBuffer[2], LL0023[z]
	mkickbuffer[2] = (unsigned short)Math::FloatAsInt(ll0023.Z());
	// ### DARS_Negative:
	dars_negative(vumem,xtop,xitop);
}
static void dars_negative(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				recurse,	vi00,					0
	recurse = 0 + (unsigned)0;
	// ### 	jr				retaddr
	return;
}
static void drawcell(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				layer,	vi00,					0
	layer = 0 + (unsigned)0;
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layer4,				layer2,					layer2
	layer4 = layer2 + (unsigned)layer2;
	// ### 	iadd			layer6,				layer4,					layer2
	layer6 = layer4 + (unsigned)layer2;
	// ### 	lq				layer[0],			133+0(layer6)
	layerv[0].Set(vumem[133+0 + layer6]);
	// ### 	lq				layer[3],			133+3(layer6)
	layerv[3].Set(vumem[133+3 + layer6]);
	// ### 	lq				layer[4],			133+4(layer6)
	layerv[4].Set(vumem[133+4 + layer6]);
	// ### 	lq				layer[5],			133+5(layer6)
	layerv[5].Set(vumem[133+5 + layer6]);
	// ### 	mini.yzw			mTexMatrix[0],	   vf00,				vf00[x]
	mtexmatrix[0].YZW(0.0f, 0.0f, 0.0f);
	// ### 	mini.xyzw			mTexMatrix[1],	   vf00,				vf00[x]
	mtexmatrix[1].Set(0.0f, 0.0f, 0.0f, 0.0f);
	// ### 	mini.xzw			mTexMatrix[2],	   vf00,				vf00[x]
	mtexmatrix[2].XZW(0.0f, 0.0f, 0.0f);
	// ### 	move.x		mTexMatrix[0],		layer[0]
	mtexmatrix[0].X(layerv[0]);
	// ### 	move.y		mTexMatrix[2],		layer[0]
	mtexmatrix[2].Y(layerv[0]);
	// ### 	lq.w			mT,					1(vi00)
	mt.W(vumem[1 + 0]);
	// ### 	mr32.xyzw	rotlayer,			layer[0]
	rotlayer.Set(layerv[0].RotateLeft());
	// ### 	mr32.xyzw	rotlayer,			rotlayer
	rotlayer.Set(rotlayer.RotateLeft());
	// ### 	mul.xy		mTexMatrix[3],		rotlayer,				mT[w]
	DoFMSETXY(mtexmatrix[3], rotlayer * mt.W());
	// ### 	mini.z			mTexMatrix[3],	   vf00,				vf00[x]
	mtexmatrix[3].Z(0.0f);
	// ### 	max.w				mTexMatrix[3],		vf00,				vf00[w]
	mtexmatrix[3].W(1.0f);
	// ### 	ftoi15.xy	mTexMatrix[3],		mTexMatrix[3]
	mtexmatrix[3].XY(Math::IntAsFloat((int)(mtexmatrix[3].x()*(1<<15))), Math::IntAsFloat((int)(mtexmatrix[3].y()*(1<<15))));
	// ### 	mtir			clampme,				mTexMatrix[3][x]
	clampme = (unsigned short)Math::FloatAsInt(mtexmatrix[3].X());
	// ### 	mfir.x		mTexMatrix[3],		clampme
	mtexmatrix[3].X(Math::IntAsFloat(clampme));
	// ### 	mtir			clampme,				mTexMatrix[3][y]
	clampme = (unsigned short)Math::FloatAsInt(mtexmatrix[3].Y());
	// ### 	mfir.y		mTexMatrix[3],		clampme
	mtexmatrix[3].Y(Math::IntAsFloat(clampme));
	// ### 	itof15.xy	mTexMatrix[3],		mTexMatrix[3]
	mtexmatrix[3].XY((float)Math::FloatAsInt(mtexmatrix[3].x())/(1<<15),(float)Math::FloatAsInt(mtexmatrix[3].y())/(1<<15));
	// ### 	mtir			layerFlags,			layer[5][x]
	layerflags = (unsigned short)Math::FloatAsInt(layerv[5].X());
	// ### 	isw.y			layerFlags,			317(vi00)
	vumem[317 + 0].Y(Math::IntAsFloat(layerflags));
	// ### 	mr32.yz		mVtxAdj,				layer[3]
	mvtxadj.YZ(layerv[3].RotateLeft());
	// ### 	mr32.xy		mVtxAdj,				mVtxAdj
	mvtxadj.XY(mvtxadj.RotateLeft());
	// ### 	add.z			mVtxAdj,				vf00,						layer[4][x]
	DoFMSETZ(mvtxadj, + layerv[4].X());
	// ### 	mr32.xyz		mNormAdj,			layer[4]
	mnormadj.XYZ(layerv[4].RotateLeft());
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[0],					0
	mkickbufferptr = mkickbuffer[0] + (unsigned)0;
	// ### 	move			vtx,					newcell
	vtxv.Set(newcell);
	// ### 	iaddiu				totalclipflags,	vi00,					0x00
	totalclipflags = 0 + (unsigned)0x00;
	// ### 	isw.z			totalclipflags,	317(vi00)
	vumem[317 + 0].Z(Math::IntAsFloat(totalclipflags));
	// ### 	mfir.x	 LL0025, depth
	ll0025.X(Math::IntAsFloat(depth));
	// ### 	mfir.y	 LL0025, quad
	ll0025.Y(Math::IntAsFloat(quad));
	// ### 	sqd.xy LL0025, (--Stack)
	vumem[--stack].XY(ll0025);
	// ### 	bal			retaddr,				AddVertex
	addvertex(vumem,xtop,xitop);
	// ### 	lqi.xyzw LL0026, (Stack++)
	ll0026.Set(vumem[stack++]);
	// ### 	mtir	 depth, LL0026[x]
	depth = (unsigned short)Math::FloatAsInt(ll0026.X());
	// ### 	mtir	 quad, LL0026[y]
	quad = (unsigned short)Math::FloatAsInt(ll0026.Y());
	// ### 	add			twice,				newcell,					newcell
	DoFMSET(twice, newcell + newcell);
	// ### 	move			gevcell,				newcell
	gevcell.Set(newcell);
	// ### 	sub.z			gevcell,				gevcell,					twice[w]
	DoFMSETZ(gevcell, gevcell - twice.W());
	// ### 	iaddiu				quad1,	vi00,					2
	quad1 = 0 + (unsigned)2;
	// ### 	iaddiu				quad2,	vi00,					3
	quad2 = 0 + (unsigned)3;
	// ### 	iaddiu				gevretidx,	vi00,					0
	gevretidx = 0 + (unsigned)0;
	// ### 	bal			gevretaddr,			GenerateEdgeVerts
	generateedgeverts(vumem,xtop,xitop);
	// ### 	move			gevcell,				newcell
	gevcell.Set(newcell);
	// ### 	add.x			gevcell,				gevcell,					twice[w]
	DoFMSETX(gevcell, gevcell + twice.W());
	// ### 	iaddiu				quad1,	vi00,					0
	quad1 = 0 + (unsigned)0;
	// ### 	iaddiu				quad2,	vi00,					2
	quad2 = 0 + (unsigned)2;
	// ### 	iaddiu				gevretidx,	vi00,					0
	gevretidx = 0 + (unsigned)0;
	// ### 	bal			gevretaddr,			GenerateEdgeVerts
	generateedgeverts(vumem,xtop,xitop);
	// ### 	move			gevcell,				newcell
	gevcell.Set(newcell);
	// ### 	add.z			gevcell,				gevcell,					twice[w]
	DoFMSETZ(gevcell, gevcell + twice.W());
	// ### 	iaddiu				quad1,	vi00,					1
	quad1 = 0 + (unsigned)1;
	// ### 	iaddiu				quad2,	vi00,					0
	quad2 = 0 + (unsigned)0;
	// ### 	iaddiu				gevretidx,	vi00,					0
	gevretidx = 0 + (unsigned)0;
	// ### 	bal			gevretaddr,			GenerateEdgeVerts
	generateedgeverts(vumem,xtop,xitop);
	// ### 	move			gevcell,				newcell
	gevcell.Set(newcell);
	// ### 	sub.x			gevcell,				gevcell,					twice[w]
	DoFMSETX(gevcell, gevcell - twice.W());
	// ### 	iaddiu				quad1,	vi00,					3
	quad1 = 0 + (unsigned)3;
	// ### 	iaddiu				quad2,	vi00,					1
	quad2 = 0 + (unsigned)1;
	// ### 	iaddiu				gevretidx,	vi00,					0
	gevretidx = 0 + (unsigned)0;
	// ### 	bal			gevretaddr,			GenerateEdgeVerts
	generateedgeverts(vumem,xtop,xitop);
	// ### 	bal			retaddr,				RenderFan
	renderfan(vumem,xtop,xitop);
	// ### 	b				DrawComplete
	drawcomplete(vumem,xtop,xitop);
	return;
}
static void rmp_environmentverts(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq.xzw		eye,					4(vi00)
	eye.XZW(vumem[4 + 0]);
	// ### 	lq.w			eyepart2,			3(vi00)
	eyepart2.W(vumem[3 + 0]);
	// ### 	mul.y			eye,					ones,						eyepart2[w]
	DoFMSETY(eye, ones * eyepart2.W());
	// ### 	lq    mClipToWorld[0], 21+0(vi00)
	mcliptoworld[0].Set(vumem[21+0 + 0]);
	// ### 	lq    mClipToWorld[1], 21+1(vi00)
	mcliptoworld[1].Set(vumem[21+1 + 0]);
	// ### 	lq    mClipToWorld[2], 21+2(vi00)
	mcliptoworld[2].Set(vumem[21+2 + 0]);
	// ### 	lq		mClipToWorld[3], 21+3(vi00)
	mcliptoworld[3].Set(vumem[21+3 + 0]);
	// ### 	lq    mWorldToLocal[0], 13+0(vi00)
	mworldtolocal[0].Set(vumem[13+0 + 0]);
	// ### 	lq    mWorldToLocal[1], 13+1(vi00)
	mworldtolocal[1].Set(vumem[13+1 + 0]);
	// ### 	lq    mWorldToLocal[2], 13+2(vi00)
	mworldtolocal[2].Set(vumem[13+2 + 0]);
	// ### 	lq		mWorldToLocal[3], 13+3(vi00)
	mworldtolocal[3].Set(vumem[13+3 + 0]);
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[0][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[0].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[0][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[0].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[0][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[0].Z());
	// ### 	madd           mClipToLocal[0], mWorldToLocal[3], mClipToWorld[0][w]
	DoFMSET(mcliptolocal[0], acc + mworldtolocal[3] * mcliptoworld[0].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[1][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[1].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[1][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[1].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[1][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[1].Z());
	// ### 	madd           mClipToLocal[1], mWorldToLocal[3], mClipToWorld[1][w]
	DoFMSET(mcliptolocal[1], acc + mworldtolocal[3] * mcliptoworld[1].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[2][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[2].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[2][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[2].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[2][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[2].Z());
	// ### 	madd           mClipToLocal[2], mWorldToLocal[3], mClipToWorld[2][w]
	DoFMSET(mcliptolocal[2], acc + mworldtolocal[3] * mcliptoworld[2].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[3][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[3].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[3][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[3].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[3][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[3].Z());
	// ### 	madd           mClipToLocal[3], mWorldToLocal[3], mClipToWorld[3][w]
	DoFMSET(mcliptolocal[3], acc + mworldtolocal[3] * mcliptoworld[3].W());
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,					temp
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));
	// ### RMP_EnvironmentVerts_Loop:
	rmp_environmentverts_loop(vumem,xtop,xitop);
}
static void rmp_environmentverts_loop(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				oldtex,				0(mKickBufferPtr)		:KICKBUFFER
	oldtex.Set(vumem[0 + mkickbufferptr]);
	// ### 	lqi			normal,				(mNormalBufferPtr++)	:NORMALBUFFER
	normal.Set(vumem[mnormalbufferptr++]);
	// ### 	mul.xyz		normal,				normal,					mNormAdj
	DoFMSETXYZ(normal, normal.Diag(mnormadj));
	// ### 	mul.xyz				LL002b,		normal,				normal
	DoFMSETXYZ(ll002b, normal.Diag(normal));
	// ### 	max.xyzw				LL0029,	   vf00,				vf00[w]
	ll0029.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL002b[x]
	DoFMSET(acc, vf0 + ll002b.X());
	// ### 	madd					ACC,			LL0029,				LL002b[y]
	DoFMSET(acc, acc + ll0029 * ll002b.Y());
	// ### 	madd					LL002a,			LL0029,				LL002b[z]
	DoFMSET(ll002a, acc + ll0029 * ll002b.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL002a[x]
	Q = Math::Sqrt(1.0f / ll002a.X());
	// ### 	mul.xyz				normal,			normal,				Q
	DoFMSETXYZ(normal, normal * Q);
	// ### 	lq				screenSpace,		2(mKickBufferPtr)		:KICKBUFFER
	screenspace.Set(vumem[2 + mkickbufferptr]);
	// ### 	itof4			screenSpace,		screenSpace
	screenspace.Set((float)Math::FloatAsInt(screenspace.x())/(1<<4),(float)Math::FloatAsInt(screenspace.y())/(1<<4),(float)Math::FloatAsInt(screenspace.z())/(1<<4),(float)Math::FloatAsInt(screenspace.w())/(1<<4));
	// ### 	div			Q,						vf00[w],					oldtex[z]
	Q = 1.0f / oldtex.Z();
	// ### 	add					acc,			mScreenToClip[3],		VF00[x]
	DoFMSET(acc, mscreentoclip[3] + 0.0f);
	// ### 	madd					acc,			mScreenToClip[0],		screenSpace[x]
	DoFMSET(acc, acc + mscreentoclip[0] * screenspace.X());
	// ### 	madd					acc,			mScreenToClip[1],		screenSpace[y]
	DoFMSET(acc, acc + mscreentoclip[1] * screenspace.Y());
	// ### 	madd					clipSpace,		mScreenToClip[2],		screenSpace[z]
	DoFMSET(clipspace, acc + mscreentoclip[2] * screenspace.Z());
	// ### 	mul.xyzw		clipSpace,			clipSpace,				Q
	DoFMSETXYZW(clipspace, clipspace * Q);
	// ### 	mul					acc,			mClipToLocal[0],		clipSpace[x]
	DoFMSET(acc, mcliptolocal[0] * clipspace.X());
	// ### 	madd					acc,			mClipToLocal[1],		clipSpace[y]
	DoFMSET(acc, acc + mcliptolocal[1] * clipspace.Y());
	// ### 	madd					acc,			mClipToLocal[2],		clipSpace[z]
	DoFMSET(acc, acc + mcliptolocal[2] * clipspace.Z());
	// ### 	madd					localSpace,		mClipToLocal[3],		clipSpace[w]
	DoFMSET(localspace, acc + mcliptolocal[3] * clipspace.W());
	// ### 	mul.xz		localSpace,			localSpace,				mScale
	DoFMSETXZ(localspace, localspace.Diag(mscale));
	// ### 	sub			toEye,				eye,						localSpace
	DoFMSET(toeye, eye - localspace);
	// ### 	mul.xyz				LL002e,		toEye,				toEye
	DoFMSETXYZ(ll002e, toeye.Diag(toeye));
	// ### 	max.xyzw				LL002c,	   vf00,				vf00[w]
	ll002c.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL002e[x]
	DoFMSET(acc, vf0 + ll002e.X());
	// ### 	madd					ACC,			LL002c,				LL002e[y]
	DoFMSET(acc, acc + ll002c * ll002e.Y());
	// ### 	madd					LL002d,			LL002c,				LL002e[z]
	DoFMSET(ll002d, acc + ll002c * ll002e.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL002d[x]
	Q = Math::Sqrt(1.0f / ll002d.X());
	// ### 	mul.xyz				toEye,			toEye,				Q
	DoFMSETXYZ(toeye, toeye * Q);
	// ### 	mul.xyz		dotA,					normal,					toEye
	DoFMSETXYZ(dota, normal.Diag(toeye));
	// ### 	eleng			P,						dotA
	P = dota.Length();
	// ### 	add.w			two,					vf00,						vf00
	DoFMSETW(two, vf0 + vf0);
	// ### 	mfp.w			dot,					P
	dot.W(P);
	// ### 	mul.w			twice,				two,						dot[w]
	DoFMSETW(twice, two * dot.W());
	// ### 	mul.xyz		normalscaled,		normal,					twice[w]
	DoFMSETXYZ(normalscaled, normal * twice.W());
	// ### 	sub.xyz		refl,					normalscaled,			toEye
	DoFMSETXYZ(refl, normalscaled - toeye);
	// ### 	mini.y			refl,	   vf00,				vf00[x]
	refl.Y(0.0f);
	// ### 	max.w				refl,		vf00,				vf00[w]
	refl.W(1.0f);
	// ### 	add			 		acc,        mTexMatrix[3], 	VF00[x]
	DoFMSET(acc, mtexmatrix[3] + 0.0f);
	// ### 	madd         		acc,        mTexMatrix[0], 	refl[x]
	DoFMSET(acc, acc + mtexmatrix[0] * refl.X());
	// ### 	madd         		acc,        mTexMatrix[1],		refl[y]
	DoFMSET(acc, acc + mtexmatrix[1] * refl.Y());
	// ### 	madd.xyz     		textureSpace, 	mTexMatrix[2],		refl[z]
	DoFMSETXYZ(texturespace, acc + mtexmatrix[2] * refl.Z());
	// ### 	mul.xy		textureSpace,		textureSpace,			oldtex[z]
	DoFMSETXY(texturespace, texturespace * oldtex.Z());
	// ### 	sq.xy			textureSpace,		0(mKickBufferPtr)		:KICKBUFFER
	vumem[0 + mkickbufferptr].XY(texturespace);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				3
	mkickbufferptr = mkickbufferptr + (unsigned)3;
	// ### 	isubiu				vtxCount,	vtxCount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibne					vtxCount,		vi00,					RMP_EnvironmentVerts_Loop
	if(vtxcount != 0) 
	{ 
		rmp_environmentverts_loop(vumem,xtop,xitop); 
		return; 
	}
	// ### 	b				RMP_DoneWithVerts
	rmp_donewithverts(vumem,xtop,xitop);
	return;
}
static void rmp_specularverts(Vector4* vumem, short xtop, short xitop)
{
	// ### 	b				RMP_DoneWithVerts
	rmp_donewithverts(vumem,xtop,xitop);return;
	// ### RMP_DistortVerts:
	rmp_distortverts(vumem,xtop,xitop);
}
static void rmp_distortverts(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq.xzw		eye,					4(vi00)
	eye.XZW(vumem[4 + 0]);
	// ### 	lq.w			eyepart2,			3(vi00)
	eyepart2.W(vumem[3 + 0]);
	// ### 	mul.y			eye,					ones,						eyepart2[w]
	DoFMSETY(eye, ones * eyepart2.W());
	// ### 	lq    mClipToWorld[0], 21+0(vi00)
	mcliptoworld[0].Set(vumem[21+0 + 0]);
	// ### 	lq    mClipToWorld[1], 21+1(vi00)
	mcliptoworld[1].Set(vumem[21+1 + 0]);
	// ### 	lq    mClipToWorld[2], 21+2(vi00)
	mcliptoworld[2].Set(vumem[21+2 + 0]);
	// ### 	lq		mClipToWorld[3], 21+3(vi00)
	mcliptoworld[3].Set(vumem[21+3 + 0]);
	// ### 	lq    mWorldToLocal[0], 13+0(vi00)
	mworldtolocal[0].Set(vumem[13+0 + 0]);
	// ### 	lq    mWorldToLocal[1], 13+1(vi00)
	mworldtolocal[1].Set(vumem[13+1 + 0]);
	// ### 	lq    mWorldToLocal[2], 13+2(vi00)
	mworldtolocal[2].Set(vumem[13+2 + 0]);
	// ### 	lq		mWorldToLocal[3], 13+3(vi00)
	mworldtolocal[3].Set(vumem[13+3 + 0]);
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[0][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[0].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[0][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[0].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[0][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[0].Z());
	// ### 	madd           mClipToLocal[0], mWorldToLocal[3], mClipToWorld[0][w]
	DoFMSET(mcliptolocal[0], acc + mworldtolocal[3] * mcliptoworld[0].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[1][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[1].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[1][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[1].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[1][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[1].Z());
	// ### 	madd           mClipToLocal[1], mWorldToLocal[3], mClipToWorld[1][w]
	DoFMSET(mcliptolocal[1], acc + mworldtolocal[3] * mcliptoworld[1].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[2][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[2].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[2][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[2].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[2][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[2].Z());
	// ### 	madd           mClipToLocal[2], mWorldToLocal[3], mClipToWorld[2][w]
	DoFMSET(mcliptolocal[2], acc + mworldtolocal[3] * mcliptoworld[2].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[3][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[3].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[3][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[3].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[3][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[3].Z());
	// ### 	madd           mClipToLocal[3], mWorldToLocal[3], mClipToWorld[3][w]
	DoFMSET(mcliptolocal[3], acc + mworldtolocal[3] * mcliptoworld[3].W());
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,					temp
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));
	// ### RMP_DistortVerts_Loop:
	rmp_distortverts_loop(vumem,xtop,xitop);
}
static void rmp_distortverts_loop(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				oldtex,				0(mKickBufferPtr)		:KICKBUFFER
	oldtex.Set(vumem[0 + mkickbufferptr]);
	// ### 	lqi			normal,				(mNormalBufferPtr++)	:NORMALBUFFER
	normal.Set(vumem[mnormalbufferptr++]);
	// ### 	mul.xyz		normal,				normal,					mNormAdj
	DoFMSETXYZ(normal, normal.Diag(mnormadj));
	// ### 	mul.xyz				LL0032,		normal,				normal
	DoFMSETXYZ(ll0032, normal.Diag(normal));
	// ### 	max.xyzw				LL0030,	   vf00,				vf00[w]
	ll0030.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL0032[x]
	DoFMSET(acc, vf0 + ll0032.X());
	// ### 	madd					ACC,			LL0030,				LL0032[y]
	DoFMSET(acc, acc + ll0030 * ll0032.Y());
	// ### 	madd					LL0031,			LL0030,				LL0032[z]
	DoFMSET(ll0031, acc + ll0030 * ll0032.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0031[x]
	Q = Math::Sqrt(1.0f / ll0031.X());
	// ### 	mul.xyz				normal,			normal,				Q
	DoFMSETXYZ(normal, normal * Q);
	// ### 	lq				screenSpace,		2(mKickBufferPtr)		:KICKBUFFER
	screenspace.Set(vumem[2 + mkickbufferptr]);
	// ### 	itof4			screenSpace,		screenSpace
	screenspace.Set((float)Math::FloatAsInt(screenspace.x())/(1<<4),(float)Math::FloatAsInt(screenspace.y())/(1<<4),(float)Math::FloatAsInt(screenspace.z())/(1<<4),(float)Math::FloatAsInt(screenspace.w())/(1<<4));
	// ### 	div			Q,						vf00[w],					oldtex[z]
	Q = 1.0f / oldtex.Z();
	// ### 	add					acc,			mScreenToClip[3],		VF00[x]
	DoFMSET(acc, mscreentoclip[3] + 0.0f);
	// ### 	madd					acc,			mScreenToClip[0],		screenSpace[x]
	DoFMSET(acc, acc + mscreentoclip[0] * screenspace.X());
	// ### 	madd					acc,			mScreenToClip[1],		screenSpace[y]
	DoFMSET(acc, acc + mscreentoclip[1] * screenspace.Y());
	// ### 	madd					clipSpace,		mScreenToClip[2],		screenSpace[z]
	DoFMSET(clipspace, acc + mscreentoclip[2] * screenspace.Z());
	// ### 	mul.xyzw		clipSpace,			clipSpace,				Q
	DoFMSETXYZW(clipspace, clipspace * Q);
	// ### 	mul					acc,			mClipToLocal[0],		clipSpace[x]
	DoFMSET(acc, mcliptolocal[0] * clipspace.X());
	// ### 	madd					acc,			mClipToLocal[1],		clipSpace[y]
	DoFMSET(acc, acc + mcliptolocal[1] * clipspace.Y());
	// ### 	madd					acc,			mClipToLocal[2],		clipSpace[z]
	DoFMSET(acc, acc + mcliptolocal[2] * clipspace.Z());
	// ### 	madd					localSpace,		mClipToLocal[3],		clipSpace[w]
	DoFMSET(localspace, acc + mcliptolocal[3] * clipspace.W());
	// ### 	add.xz		localSpace,			localSpace,				normal
	DoFMSETXZ(localspace, localspace + normal);
	// ### 	mul					acc,			mLocalToClip[0],		localSpace[x]
	DoFMSET(acc, mlocaltoclip[0] * localspace.X());
	// ### 	madd					acc,			mLocalToClip[1],		localSpace[y]
	DoFMSET(acc, acc + mlocaltoclip[1] * localspace.Y());
	// ### 	madd					acc,			mLocalToClip[2],		localSpace[z]
	DoFMSET(acc, acc + mlocaltoclip[2] * localspace.Z());
	// ### 	madd					clipSpace,		mLocalToClip[3],		localSpace[w]
	DoFMSET(clipspace, acc + mlocaltoclip[3] * localspace.W());
	// ### 	div			Q,						vf00[w],					clipSpace[w]
	Q = 1.0f / clipspace.W();
	// ### 	mul.xyzw		canonicalSpace,	clipSpace,				Q
	DoFMSETXYZW(canonicalspace, clipspace * Q);
	// ### 	loi 0.5
	I = 0.5;
	// ### 	mul.xy		textureSpace,		clipSpace,				I
	DoFMSETXY(texturespace, clipspace * I);
	// ### 	add.xy		textureSpace,		textureSpace,			I
	DoFMSETXY(texturespace, texturespace + I);
	// ### 	mini.z			textureSpace,	   vf00,				vf00[x]
	texturespace.Z(0.0f);
	// ### 	add			 		acc,        mTexMatrix[3], 	VF00[x]
	DoFMSET(acc, mtexmatrix[3] + 0.0f);
	// ### 	madd         		acc,        mTexMatrix[0], 	textureSpace[x]
	DoFMSET(acc, acc + mtexmatrix[0] * texturespace.X());
	// ### 	madd         		acc,        mTexMatrix[1],		textureSpace[y]
	DoFMSET(acc, acc + mtexmatrix[1] * texturespace.Y());
	// ### 	madd.xyz     		textureSpace, 	mTexMatrix[2],		textureSpace[z]
	DoFMSETXYZ(texturespace, acc + mtexmatrix[2] * texturespace.Z());
	// ### 	mul.xy		textureSpace,		textureSpace,			oldtex[z]
	DoFMSETXY(texturespace, texturespace * oldtex.Z());
	// ### 	sq.xy			textureSpace,		0(mKickBufferPtr)		:KICKBUFFER
	vumem[0 + mkickbufferptr].XY(texturespace);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				3
	mkickbufferptr = mkickbufferptr + (unsigned)3;
	// ### 	isubiu				vtxCount,	vtxCount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibne					vtxCount,		vi00,					RMP_DistortVerts_Loop
	if(vtxcount != 0) 
	{ 
		rmp_distortverts_loop(vumem,xtop,xitop);
		return; 
	}
	// ### 	b				RMP_DoneWithVerts
	rmp_donewithverts(vumem,xtop,xitop);
	return;
}
static void addvertex(Vector4* vumem, short xtop, short xitop)
{
	// ### 	max.w				vtx,		vf00,				vf00[w]
	vtxv.W(1.0f);
	// ### 	b				GetY
	gety(vumem,xtop,xitop);
	return;
}
static void returnfromgety(Vector4* vumem, short xtop, short xitop)
{
	// ### 	ilw.x			flags0,				4(vi00)
	flags0 = Math::FloatAsInt(vumem[4 + 0].x());
	// ### 	iaddiu				LL0033,	vi00,					1
	ll0033 = 0 + (unsigned)1;
	// ### 	iand					LL0033,		flags0,				LL0033
	ll0033 = flags0 & ll0033;
	// ### 	ibeq					LL0033,		VI00,					DontRenderNormals
	if(ll0033 == 0) 
	{ 
		dontrendernormals(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				LL0034,	vi00,					1
	ll0034 = 0 + (unsigned)1;
	// ### 	iaddiu				LL0035,	vi00,					319
	ll0035 = 0 + (unsigned)319;
	// ### 	lq				LL003e,					3(vi00)
	ll003e.Set(vumem[3 + 0]);
	// ### 	iaddiu				LL003c,	vi00,					1
	ll003c = 0 + (unsigned)1;
	// ### 	iaddiu				LL003c,	LL003c,				0x7fff
	ll003c = ll003c + (unsigned)0x7fff;
	// ### 	ior			LL003d,				LL0034,				LL003c
	ll003d = ll0034 | ll003c;
	// ### 	mfir.x		LL003e,					LL003d
	ll003e.X(Math::IntAsFloat(ll003d));
	// ### 	sqi			LL003e,					(LL0035++)	:KICKBUFFER
	vumem[ll0035++].Set(ll003e);
	// ### 	iaddiu				LL0041,	vi00,					0x1
	ll0041 = 0 + (unsigned)0x1;
	// ### 	mfir			LL0041,					LL0041
	ll0041v.Set(Math::IntAsFloat(ll0041),Math::IntAsFloat(ll0041),Math::IntAsFloat(ll0041),Math::IntAsFloat(ll0041));
	// ### 	iaddiu				LL0042,	vi00,					0xE
	ll0042 = 0 + (unsigned)0xe;
	// ### 	isw.z			LL0042,				319(vi00)
	vumem[319 + 0].Z(Math::IntAsFloat(ll0042));
	// ### 	iaddiu				LL0042,	vi00,					0x00
	ll0042 = 0 + (unsigned)0x00;
	// ### 	mfir.z		LL0041,					LL0042
//	ll0041.Z(Math::IntAsFloat(ll0042));
	ll0041v.Z(Math::IntAsFloat(ll0042));			// PAB
	// ### 	sq.xyz		LL0041,					319+1(vi00)
	vumem[319+1 + 0].XYZ(ll0041);
	// ### 	iaddiu				LL0043,	vi00,					319
	ll0043 = 0 + (unsigned)319;
	// ### 	xgkick		LL0043
	XGKICK(vumem, ll0043);
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### 	loi				0x7F00007F
	I = Math::IntAsFloat(0x7f00007f);
	// ### 	mul				color,			ones,						I
	DoFMSET(color, ones * I);
	// ### 	iaddiu				LL0044,	vi00,					0xE
	ll0044 = 0 + (unsigned)0xe;
	// ### 	isw.z			LL0044,				319(vi00)
	vumem[319 + 0].Z(Math::IntAsFloat(ll0044));
	// ### 	iaddiu				LL0044,	vi00,					0x01
	ll0044 = 0 + (unsigned)0x01;
	// ### 	mfir.z		color,					LL0044
	color.Z(Math::IntAsFloat(ll0044));
	// ### 	sq.xyz		color,					319+1(vi00)
	vumem[319+1 + 0].XYZ(color);
	// ### 	iaddiu				LL0045,	vi00,					319
	ll0045 = 0 + (unsigned)319;
	// ### 	xgkick		LL0045
	XGKICK(vumem, ll0045);
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### 	loi				0x38F30000
	I = Math::IntAsFloat(0x38f30000);
	// ### 	mul				test,				ones,						I
	DoFMSET(test, ones * I);
	// ### 	iaddiu				LL0046,	vi00,					0xE
	ll0046 = 0 + (unsigned)0xe;
	// ### 	isw.z			LL0046,				319(vi00)
	vumem[319 + 0].Z(Math::IntAsFloat(ll0046));
	// ### 	iaddiu				LL0046,	vi00,					0x47
	ll0046 = 0 + (unsigned)0x47;
	// ### 	mfir.z		test,					LL0046
	test.Z(Math::IntAsFloat(ll0046));
	// ### 	sq.xyz		test,					319+1(vi00)
	vumem[319+1 + 0].XYZ(test);
	// ### 	iaddiu				LL0047,	vi00,					319
	ll0047 = 0 + (unsigned)319;
	// ### 	xgkick		LL0047
	XGKICK(vumem, ll0047);
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### 	add					acc,			mLocalToClip[3],		VF00[x]
	DoFMSET(acc, mlocaltoclip[3] + 0.0f);
	// ### 	madd					acc,			mLocalToClip[0],		vtx[x]
	DoFMSET(acc, acc + mlocaltoclip[0] * vtxv.X());
	// ### 	madd					acc,			mLocalToClip[1],		vtx[y]
	DoFMSET(acc, acc + mlocaltoclip[1] * vtxv.Y());
	// ### 	madd					LL0038,		mLocalToClip[2],		vtx[z]
	DoFMSET(ll0038, acc + mlocaltoclip[2] * vtxv.Z());
	// ### 	div			Q,						vf00[w],					LL0038[w]
	Q = 1.0f / ll0038.W();
	// ### 	clipw			LL0038,			LL0038
	Clip(ll0038,ll0038);
	// ### 	fcand			vi01,					0x00003F
	vi1 = (FC & 0x00003f) ? 1 : 0;
	// ### 	ibne					vi01,		vi00,					skipit158
	if(vi1 != 0) 
	{ 
		skipit158(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mul.xyz		LL0038,			LL0038,				Q
	DoFMSETXYZ(ll0038, ll0038 * Q);
	// ### 	lq    LL0037[0], 9+0(vi00)
	ll0037[0].Set(vumem[9+0 + 0]);
	// ### 	lq    LL0037[1], 9+1(vi00)
	ll0037[1].Set(vumem[9+1 + 0]);
	// ### 	lq    LL0037[2], 9+2(vi00)
	ll0037[2].Set(vumem[9+2 + 0]);
	// ### 	lq		LL0037[3], 9+3(vi00)
	ll0037[3].Set(vumem[9+3 + 0]);
	// ### 	add					acc,			LL0037[3],		VF00[x]
	DoFMSET(acc, ll0037[3] + 0.0f);
	// ### 	madd					acc,			LL0037[0],		LL0038[x]
	DoFMSET(acc, acc + ll0037[0] * ll0038.X());
	// ### 	madd					acc,			LL0037[1],		LL0038[y]
	DoFMSET(acc, acc + ll0037[1] * ll0038.Y());
	// ### 	madd					LL003b,		LL0037[2],		LL0038[z]
	DoFMSET(ll003b, acc + ll0037[2] * ll0038.Z());
	// ### 	ftoi4.xyz	LL003b,		LL003b
	ll003b.XYZ(Math::IntAsFloat((int)(ll003b.x()*(1<<4))), Math::IntAsFloat((int)(ll003b.y()*(1<<4))), Math::IntAsFloat((int)(ll003b.z()*(1<<4))));
	// ### 	mini.w			LL003b,	   vf00,				vf00[x]
	ll003b.W(0.0f);
	// ### 	iaddiu				LL0048,	vi00,					0x4
	ll0048 = 0 + (unsigned)0x4;
	// ### 	isw.z			LL0048,				319(vi00)
	vumem[319 + 0].Z(Math::IntAsFloat(ll0048));
	// ### 	sq				LL003b,					319+1(vi00)
	vumem[319+1 + 0].Set(ll003b);
	// ### 	iaddiu				LL0049,	vi00,					319
	ll0049 = 0 + (unsigned)319;
	// ### 	xgkick		LL0049
	XGKICK(vumem, ll0049);
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### 	move.xyz		scalednormal,		normal
	scalednormal.XYZ(normal);
	// ### 	mul.xyz				LL004c,		scalednormal,				scalednormal
	DoFMSETXYZ(ll004c, scalednormal.Diag(scalednormal));
	// ### 	max.xyzw				LL004a,	   vf00,				vf00[w]
	ll004a.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL004c[x]
	DoFMSET(acc, vf0 + ll004c.X());
	// ### 	madd					ACC,			LL004a,				LL004c[y]
	DoFMSET(acc, acc + ll004a * ll004c.Y());
	// ### 	madd					LL004b,			LL004a,				LL004c[z]
	DoFMSET(ll004b, acc + ll004a * ll004c.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL004b[x]
	Q = Math::Sqrt(1.0f / ll004b.X());
	// ### 	mul.xyz				scalednormal,			scalednormal,				Q
	DoFMSETXYZ(scalednormal, scalednormal * Q);
	// ### 	loi			0.25
	I = 0.25;
	// ### 	mul.xyz		scalednormal,		scalednormal,			I
	DoFMSETXYZ(scalednormal, scalednormal * I);
	// ### 	add.xyz		LL003a,				scalednormal,			vtx
	DoFMSETXYZ(ll003a, scalednormal + vtx);
	// ### 	add					acc,			mLocalToClip[3],		VF00[x]
	DoFMSET(acc, mlocaltoclip[3] + 0.0f);
	// ### 	madd					acc,			mLocalToClip[0],		LL003a[x]
	DoFMSET(acc, acc + mlocaltoclip[0] * ll003a.X());
	// ### 	madd					acc,			mLocalToClip[1],		LL003a[y]
	DoFMSET(acc, acc + mlocaltoclip[1] * ll003a.Y());
	// ### 	madd					LL0038,		mLocalToClip[2],		LL003a[z]
	DoFMSET(ll0038, acc + mlocaltoclip[2] * ll003a.Z());
	// ### 	div			Q,						vf00[w],					LL0038[w]
	Q = 1.0f / ll0038.W();
	// ### 	mul.xyz		LL0038,			LL0038,				Q
	DoFMSETXYZ(ll0038, ll0038 * Q);
	// ### 	add					acc,			LL0037[3],		VF00[x]
	DoFMSET(acc, ll0037[3] + 0.0f);
	// ### 	madd					acc,			LL0037[0],		LL0038[x]
	DoFMSET(acc, acc + ll0037[0] * ll0038.X());
	// ### 	madd					acc,			LL0037[1],		LL0038[y]
	DoFMSET(acc, acc + ll0037[1] * ll0038.Y());
	// ### 	madd					LL003b,		LL0037[2],		LL0038[z]
	DoFMSET(ll003b, acc + ll0037[2] * ll0038.Z());
	// ### 	ftoi4.xyz	LL003b,		LL003b
	ll003b.XYZ(Math::IntAsFloat((int)(ll003b.x()*(1<<4))), Math::IntAsFloat((int)(ll003b.y()*(1<<4))), Math::IntAsFloat((int)(ll003b.z()*(1<<4))));
	// ### 	mini.w			LL003b,	   vf00,				vf00[x]
	ll003b.W(0.0f);
	// ### 	iaddiu				LL004d,	vi00,					0x4
	ll004d = 0 + (unsigned)0x4;
	// ### 	isw.z			LL004d,				319(vi00)
	vumem[319 + 0].Z(Math::IntAsFloat(ll004d));
	// ### 	sq				LL003b,					319+1(vi00)
	vumem[319+1 + 0].Set(ll003b);
	// ### 	iaddiu				LL004e,	vi00,					319
	ll004e = 0 + (unsigned)319;
	// ### 	xgkick		LL004e
	XGKICK(vumem, ll004e);
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### skipit158:
	skipit158(vumem,xtop,xitop);
}
static void skipit158(Vector4* vumem, short xtop, short xitop)
{
	// ### DontRenderNormals:
	dontrendernormals(vumem,xtop,xitop);
}
static void dontrendernormals(Vector4* vumem, short xtop, short xitop)
{
	// ### 	move			worldvtx,			vtx
//pab	worldvtx.Set(vtx);
	worldvtx.Set(vtx, vtx, vtx, vtx);
	// ### 	add					acc,			mLocalToClip[3],		VF00[x]
	DoFMSET(acc, mlocaltoclip[3] + 0.0f);
	// ### 	madd					acc,			mLocalToClip[0],		worldvtx[x]
	DoFMSET(acc, acc + mlocaltoclip[0] * worldvtx.X());
	// ### 	madd					acc,			mLocalToClip[1],		worldvtx[y]
	DoFMSET(acc, acc + mlocaltoclip[1] * worldvtx.Y());
	// ### 	madd					screenvtx,		mLocalToClip[2],		worldvtx[z]
	DoFMSET(screenvtx, acc + mlocaltoclip[2] * worldvtx.Z());
	// ### 	loi			0.28
	I = 0.28f;
	// ### 	mul.xy		testvtx,				screenvtx,				I
	DoFMSETXY(testvtx, screenvtx * I);
	// ### 	move.z		testvtx,				screenvtx
	testvtx.Z(screenvtx);
	// ### 	clipw			testvtx,				screenvtx
	Clip(testvtx,screenvtx);
	// ### 	ilw.z			totalclipflags,	317(vi00)
	totalclipflags = Math::FloatAsInt(vumem[317 + 0].z());
	// ### 	fcget			clipflags
	clipflags = FC;
	// ### 	ior			totalclipflags,	totalclipflags,		clipflags
	totalclipflags = totalclipflags | clipflags;
	// ### 	isw.z			totalclipflags,	317(vi00)
	vumem[317 + 0].Z(Math::IntAsFloat(totalclipflags));
	// ### 	sqi			screenvtx,			(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(screenvtx);
	// ### 	sqi.xyz		vtx,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(vtx);
	// ### 	sqi			normal,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(normal);
	// ### 	jr				retaddr
	return;
}
static void gety(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mini.y			vtx,	   vf00,				vf00[x]
	vtxv.Y(0.0f);
	// ### 	mini.xz			normal,	   vf00,				vf00[x]
	normal.XZ(0.0f, 0.0f);
	// ### 	max.y				normal,		vf00,				vf00[w]
	normal.Y(1.0f);
	// ### 	lq				miscqw24,			25(vi00)
	miscqw24.Set(vumem[25 + 0]);
	// ### 	add.xz		offsetvtx,			vtx,						miscqw24
	DoFMSETXZ(offsetvtx, vtxv + miscqw24);
	// ### 	iaddiu				bytemask,	vi00,					0xFF
	bytemask = 0 + (unsigned)0xff;
	// ### 	ilw.w			counter,				125(vi00)
	counter = Math::FloatAsInt(vumem[125 + 0].w());
	// ### 	iand			counter,				counter,					bytemask
	counter = counter & bytemask;
	// ### 	mini.xyzw			ringnormal,		vf00,				vf00[x]
	ringnormal.Set(0.0f, 0.0f, 0.0f, 0.0f);
	// ### 	ibeq					counter,		vi00,					GY_SkipRings
	if(counter == 0) 
	{ 
		gy_skiprings(vumem,xtop,xitop);
		return; 
	}
	// ### 	lq				ringParams1,		26(vi00)
	ringparams1.Set(vumem[26 + 0]);
	// ### 	lq				ringParams2,		27(vi00)
	ringparams2.Set(vumem[27 + 0]);
	// ### 	lq				ringParams3,		28(vi00)
	ringparams3.Set(vumem[28 + 0]);
	// ### 	lq.w			mT,					1(vi00)
	mt.W(vumem[1 + 0]);
	// ### 	iaddiu				wsignmask,	vi00,					0x10
	wsignmask = 0 + (unsigned)0x10;
	// ### GY_RING_LOOP:
	gy_ring_loop(vumem,xtop,xitop);
}
static void gy_ring_loop(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				counter,	counter,				1
	counter = counter - (unsigned)1;
	// ### 	lq				ring,					125(counter)
	ring.Set(vumem[125 + counter]);
	// ### 	sub.w			age,					mT,						ring[y]
	DoFMSETW(age, mt - ring.Y());
	// ### 	sub.xz		delta,				offsetvtx,				ring
	DoFMSETXZ(delta, offsetvtx - ring);
	// ### 	mini.y			delta,	   vf00,				vf00[x]
	delta.Y(0.0f);
	// ### 	eleng			P,						delta
	P = delta.Length();
	// ### 	mfp.w			distance,			P
	distance.W(P);
	// ### 	mul.w			growth,				age,						ringParams1[x]
	DoFMSETW(growth, age * ringparams1.X());
	// ### 	sub.w			dbase,				distance,				growth
	DoFMSETW(dbase, distance - growth);
	// ### 	add.w			dbase,				dbase,					ringParams1[y]
	DoFMSETW(dbase, dbase + ringparams1.Y());
	// ### 	mul.w			angle,				dbase,					ringParams1[z]
	DoFMSETW(angle, dbase * ringparams1.Z());
	// ### 	mul.w			rampposinit,		angle,					ringParams1[w]
	DoFMSETW(rampposinit, angle * ringparams1.W());
	// ### 	fmand			wsignbit,			wsignmask
	wsignbit = FM & wsignmask;
	// ### 	mfir.w		wsign0,				wsignbit
	wsign0.W(Math::IntAsFloat(wsignbit));
	// ### 	sub.w			vf00,					vf00,						rampposinit
	DoFMSETW(vf0, vf0 - rampposinit);
	// ### 	fmand			wsignbit,			wsignmask
	wsignbit = FM & wsignmask;
	// ### 	mfir.z		wsign0,				wsignbit
	wsign0.Z(Math::IntAsFloat(wsignbit));
	// ### 	itof4.zw		wsign0,				wsign0
	wsign0.ZW((float)Math::FloatAsInt(wsign0.z())/(1<<4),(float)Math::FloatAsInt(wsign0.w())/(1<<4));
	// ### 	max.zw				ones,		vf00,				vf00[w]
	ones.ZW(1.);
	// ### 	sub.zw		wsign0,				ones,						wsign0
	DoFMSETZW(wsign0, ones - wsign0);
	// ### 	mul.w			wsign0,				wsign0,					wsign0[z]
	DoFMSETW(wsign0, wsign0 * wsign0.Z());
	// ### 	loi			2.0
	I = 2.0;
	// ### 	mul.w			ramppos,				rampposinit,			I
	DoFMSETW(ramppos, rampposinit * I);
	// ### 	sub.w			ramppos,				ramppos,					vf00[w]
	DoFMSETW(ramppos, ramppos - 1.0f);
	// ### 	abs.w			ramppos,				ramppos
	ramppos.W(ramppos.Abs());
	// ### 	sub.w			ramppos,				vf00,						ramppos
	DoFMSETW(ramppos, vf0 - ramppos);
	// ### 	add.w			cosin,				angle,					ringParams2[x]
	DoFMSETW(cosin, angle + ringparams2.X());
	// ### 	mr32.z		cosin,				cosin
	cosin.Z(cosin.RotateLeft());
	// ### 	mini.xy			cosin,	   vf00,				vf00[x]
	cosin.XY(0.0f, 0.0f);
	// ### 	loi 0x3fc90fdb
	I = Math::IntAsFloat(0x3fc90fdb);
	// ### 	sub.xz				LL004f,		cosin,				I
	DoFMSETXZ(ll004f, cosin - I);
	// ### 	move.yw				LL004f,		cosin
	ll004f.YW(cosin);
	// ### 	abs					t1,			LL004f
	t1.Set(ll004f.Abs());
	// ### 	max.xyzw				t2,	   vf00,				vf00[w]
	t2.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	loi					0xbe22f983
	I = Math::IntAsFloat(0xbe22f983);
	// ### 	mul					ACC,			t1,				I
	DoFMSET(acc, t1 * I);
	// ### 	loi					0x4b400000
	I = Math::IntAsFloat(0x4b400000);
	// ### 	msub					ACC,			t2,				I
	DoFMSET(acc, acc - t2 * I);
	// ### 	madd					ACC,			t2,				I
	DoFMSET(acc, acc + t2 * I);
	// ### 	loi					0xbe22f983
	I = Math::IntAsFloat(0xbe22f983);
	// ### 	msub					ACC,			t1,				I
	DoFMSET(acc, acc - t1 * I);
	// ### 	loi					0.5
	I = 0.5;
	// ### 	msub					t1,			t2,				I
	DoFMSET(t1, acc - t2 * I);
	// ### 	abs					t1,			t1
	t1.Set(t1.Abs());
	// ### 	loi					0.25
	I = 0.25;
	// ### 	sub					t1,			t1,				I
	DoFMSET(t1, t1 - I);
	// ### 	mul					t2,			t1,				t1
	DoFMSET(t2, t1.Diag(t1));
	// ### 	loi					0xc2992661
	I = Math::IntAsFloat(0xc2992661);
	// ### 	mul					t6,			t1,				I
	DoFMSET(t6, t1 * I);
	// ### 	loi					0xc2255de0
	I = Math::IntAsFloat(0xc2255de0);
	// ### 	mul					t4,			t1,				I
	DoFMSET(t4, t1 * I);
	// ### 	loi					0x42a33457
	I = Math::IntAsFloat(0x42a33457);
	// ### 	mul					t5,			t1,				I
	DoFMSET(t5, t1 * I);
	// ### 	mul					t3,			t2,				t2
	DoFMSET(t3, t2.Diag(t2));
	// ### 	mul					t6,			t6,				t2
	DoFMSET(t6, t6.Diag(t2));
	// ### 	mul					ACC,			t4,				t2
	DoFMSET(acc, t4.Diag(t2));
	// ### 	loi					0x421ed7b7
	I = Math::IntAsFloat(0x421ed7b7);
	// ### 	mul					t4,			t1,				I
	DoFMSET(t4, t1 * I);
	// ### 	mul					t2,			t3,				t3
	DoFMSET(t2, t3.Diag(t3));
	// ### 	madd					ACC,			t6,				t3
	DoFMSET(acc, acc + t6.Diag(t3));
	// ### 	madd					ACC,			t5,				t3
	DoFMSET(acc, acc + t5.Diag(t3));
	// ### 	loi					0x40c90fda
	I = Math::IntAsFloat(0x40c90fda);
	// ### 	madd					ACC,			t1,				I
	DoFMSET(acc, acc + t1 * I);
	// ### 	madd					cosout,		t4,				t2
	DoFMSET(cosout, acc + t4.Diag(t2));
	// ### 	mul.w			posscale,			cosout,					ramppos
	DoFMSETW(posscale, cosout.Diag(ramppos));
	// ### 	mul.w			posscale,			posscale,				ringParams2[y]
	DoFMSETW(posscale, posscale * ringparams2.Y());
	// ### 	mul.w			posscale,			posscale,				wsign0[w]
	DoFMSETW(posscale, posscale * wsign0.W());
	// ### 	sub.w			vf00,					age,						ringParams2[z]
	DoFMSETW(vf0, age - ringparams2.Z());
	// ### 	fmand			wsignbit,			wsignmask
	wsignbit = FM & wsignmask;
	// ### 	mfir.x		wsign,				wsignbit
	wsign.X(Math::IntAsFloat(wsignbit));
	// ### 	itof4.x		wsign,				wsign
	wsign.X((float)Math::FloatAsInt(wsign.x())/(1<<4));
	// ### 	mul.w			timescaleA,			age,						ringParams2[w]
	DoFMSETW(timescalea, age * ringparams2.W());
	// ### 	mul.w			ACC,					timescaleA,				wsign[x]
	DoFMSETW(acc, timescalea * wsign.X());
	// ### 	sub.w			wsign2,				vf00,						wsign[x]
	DoFMSETW(wsign2, vf0 - wsign.X());
	// ### 	sub.w			vf00,					age,						ringParams3[x]
	DoFMSETW(vf0, age - ringparams3.X());
	// ### 	fmand			wsignbit,			wsignmask
	wsignbit = FM & wsignmask;
	// ### 	mfir.y		wsign3,				wsignbit
	wsign3.Y(Math::IntAsFloat(wsignbit));
	// ### 	itof4.y		wsign3,				wsign3
	wsign3.Y((float)Math::FloatAsInt(wsign3.y())/(1<<4));
	// ### 	mul.y			timescaleB,			wsign3,					wsign2[w]
	DoFMSETY(timescaleb, wsign3 * wsign2.W());
	// ### 	madd.w		ACC,					vf00,						timescaleB[y]
	DoFMSETW(acc, acc + vf0 * timescaleb.Y());
	// ### 	sub.w			wsign4,				vf00,						timescaleB[y]
	DoFMSETW(wsign4, vf0 - timescaleb.Y());
	// ### 	sub.w			agediff,				age,						ringParams3[x]
	DoFMSETW(agediff, age - ringparams3.X());
	// ### 	mul.w			agediff,				agediff,					ringParams3[y]
	DoFMSETW(agediff, agediff * ringparams3.Y());
	// ### 	sub.w			timescaleC,			vf00,						agediff
	DoFMSETW(timescalec, vf0 - agediff);
	// ### 	madd.w		timescale,			timescaleC,				wsign4
	DoFMSETW(timescale, acc + timescalec.Diag(wsign4));
	// ### 	mul.w			height,				timescale,				posscale
	DoFMSETW(height, timescale.Diag(posscale));
	// ### 	add.y			vtx,					vtx,						height[w]
	DoFMSETY(vtxv, vtxv + height.W());
	// ### 	mr32			vertnorm,			vf00
	vertnorm.Set(vf0.RotateLeft());
	// ### 	mr32			vertnorm,			vertnorm
	vertnorm.Set(vertnorm.RotateLeft());
	// ### 	mul.xyz				LL0052,		delta,				delta
	DoFMSETXYZ(ll0052, delta.Diag(delta));
	// ### 	max.xyzw				LL0050,	   vf00,				vf00[w]
	ll0050.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL0052[x]
	DoFMSET(acc, vf0 + ll0052.X());
	// ### 	madd					ACC,			LL0050,				LL0052[y]
	DoFMSET(acc, acc + ll0050 * ll0052.Y());
	// ### 	madd					LL0051,			LL0050,				LL0052[z]
	DoFMSET(ll0051, acc + ll0050 * ll0052.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0051[x]
	Q = Math::Sqrt(1.0f / ll0051.X());
	// ### 	mul.xyz				horiznorm,			delta,				Q
	DoFMSETXYZ(horiznorm, delta * Q);
	// ### 	mul.z			cosout,				cosout,					timescale[w]
	DoFMSETZ(cosout, cosout * timescale.W());
	// ### 	mul.z			cosout,				cosout,					ringParams2[y]
	DoFMSETZ(cosout, cosout * ringparams2.Y());
	// ### 	sub.w			oneminussin,		vf00,						cosout[z]
	DoFMSETW(oneminussin, vf0 - cosout.Z());
	// ### 	mul.xyz		ACC,					horiznorm,				cosout[z]
	DoFMSETXYZ(acc, horiznorm * cosout.Z());
	// ### 	madd.xyz		thisringnorm,		vertnorm,				oneminussin[w]
	DoFMSETXYZ(thisringnorm, acc + vertnorm * oneminussin.W());
	// ### 	mul.xyz		thisringnorm,		thisringnorm,			wsign0[w]
	DoFMSETXYZ(thisringnorm, thisringnorm * wsign0.W());
	// ### 	add.xyz		ringnormal,			ringnormal,				thisringnorm
	DoFMSETXYZ(ringnormal, ringnormal + thisringnorm);
	// ### 	ibne					counter,		vi00,					GY_RING_LOOP
	if(counter != 0) 
	{ 
		gy_ring_loop(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mul.xyz				LL0055,		ringnormal,				ringnormal
	DoFMSETXYZ(ll0055, ringnormal.Diag(ringnormal));
	// ### 	max.xyzw				LL0053,	   vf00,				vf00[w]
	ll0053.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL0055[x]
	DoFMSET(acc, vf0 + ll0055.X());
	// ### 	madd					ACC,			LL0053,				LL0055[y]
	DoFMSET(acc, acc + ll0053 * ll0055.Y());
	// ### 	madd					LL0054,			LL0053,				LL0055[z]
	DoFMSET(ll0054, acc + ll0053 * ll0055.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0054[x]
	Q = Math::Sqrt(1.0f / ll0054.X());
	// ### 	mul.xyz				ringnormal,			ringnormal,				Q
	DoFMSETXYZ(ringnormal, ringnormal * Q);
	// ### 	add.xyz		normal,				normal,					ringnormal
	DoFMSETXYZ(normal, normal + ringnormal);
	// ### GY_SkipRings:
	gy_skiprings(vumem,xtop,xitop);
}
static void gy_skiprings(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.xz		VtxXZXZ,				ones,						offsetvtx[x]
	DoFMSETXZ(vtxxzxz, ones * offsetvtx.X());
	// ### 	mul.yw		VtxXZXZ,				ones,						offsetvtx[z]
	DoFMSETYW(vtxxzxz, ones * offsetvtx.Z());
	// ### 	mul.xz		wakeradiussq,		ones,						miscqw24[w]
	DoFMSETXZ(wakeradiussq, ones * miscqw24.W());
	// ### 	div			Q,						vf00[w],					wakeradiussq[x]
	Q = 1.0f / wakeradiussq.X();
	// ### 	mul.w			invradiussq,		vf00,						Q
	DoFMSETW(invradiussq, vf0 * Q);
	// ### 	mini.xyzw			totalwakescale,		vf00,				vf00[x]
	totalwakescale.Set(0.0f, 0.0f, 0.0f, 0.0f);
	// ### 	ilw.y,		counter,				100(vi00)
	// ### 	iand			counter,				counter,					bytemask
	counter = counter & bytemask;
	// ### 	mini.xyzw			totalwakenormal,		vf00,				vf00[x]
	totalwakenormal.Set(0.0f, 0.0f, 0.0f, 0.0f);
	// ### 	iaddiu				hasnormal,	vi00,					0
	hasnormal = 0 + (unsigned)0;
	// ### 	ibeq					counter,		vi00,					GY_SkipWakes
	if(counter == 0) 
	{ 
		gy_skipwakes(vumem,xtop,xitop); 
		return; 
	}
	// ### GY_WAKE_LOOP:
	gy_wake_loop(vumem,xtop,xitop);
}
static void gy_wake_loop(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				counter,	counter,				1
	counter = counter - (unsigned)1;
	// ### 	lq				wakepair,			100(counter)
	wakepair.Set(vumem[100 + counter]);
	// ### 	sub			wakediff,			wakepair,				VtxXZXZ
	DoFMSET(wakediff, wakepair - vtxxzxz);
	// ### 	mul			wakediffsq,			wakediff,				wakediff
	DoFMSET(wakediffsq, wakediff.Diag(wakediff));
	// ### 	mr32.xz		wakediffsqrot,		wakediffsq
	wakediffsqrot.XZ(wakediffsq.RotateLeft());
	// ### 	add.xz		wakelensq,			wakediffsq,				wakediffsqrot
	DoFMSETXZ(wakelensq, wakediffsq + wakediffsqrot);
	// ### 	mini.xz		wakelensq,			wakeradiussq,			wakelensq
	wakelensq.XZ(Vector4::Min(wakeradiussq, wakelensq));
	// ### 	sub.xz		wakedistsq,			wakeradiussq,			wakelensq
	DoFMSETXZ(wakedistsq, wakeradiussq - wakelensq);
	// ### 	mul.xz		wakedistscale,		wakedistsq,				invradiussq[w]
	DoFMSETXZ(wakedistscale, wakedistsq * invradiussq.W());
	// ### 	mtir			wakescale1,			wakepair[x]
	wakescale1 = (unsigned short)Math::FloatAsInt(wakepair.X());
	// ### 	mtir			wakescale2,			wakepair[z]
	wakescale2 = (unsigned short)Math::FloatAsInt(wakepair.Z());
	// ### 	iand			wakescale1,			wakescale1,				bytemask
	wakescale1 = wakescale1 & bytemask;
	// ### 	iand			wakescale2,			wakescale2,				bytemask
	wakescale2 = wakescale2 & bytemask;
	// ### 	mfir.x		wakepassscale,		wakescale1
	wakepassscale.X(Math::IntAsFloat(wakescale1));
	// ### 	mfir.z		wakepassscale,		wakescale2
	wakepassscale.Z(Math::IntAsFloat(wakescale2));
	// ### 	itof0.xz		wakepassscale,		wakepassscale
	wakepassscale.XZ((float)Math::FloatAsInt(wakepassscale.x())/(1<<0),(float)Math::FloatAsInt(wakepassscale.z())/(1<<0));
	// ### 	loi			0x3C008081		  
	I = Math::IntAsFloat(0x3c008081);
	// ### 	muli.xz		wakepassscale,		wakepassscale,			I
	DoFMSETXZ(wakepassscale, wakepassscale * I);
	// ### 	mul.xz		wakescale,			wakedistscale,			wakepassscale
	DoFMSETXZ(wakescale, wakedistscale.Diag(wakepassscale));
	// ### 	mul.xz		normysq,				wakedistscale,			wakedistscale
	DoFMSETXZ(normysq, wakedistscale.Diag(wakedistscale));
	// ### 	sub.xz		oneminusy,			ones,						normysq
	DoFMSETXZ(oneminusy, ones - normysq);
	// ### 	iaddiu				LL0057,	vi00,					0x0088
	ll0057 = 0 + (unsigned)0x0088;
	// ### 	sub.x			vf00,		wakescale,	totalwakescale
	DoFMSETX(vf0, wakescale - totalwakescale);
	// ### 	fmand					LL0056,		LL0057
	ll0056 = FM & ll0057;
	// ### 	ibne					LL0056,		vi00,					GY_DontMakeNormal1
	if(ll0056 != 0) 
	{ 
		gy_dontmakenormal1(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				LL0059,	vi00,					0x0088
	ll0059 = 0 + (unsigned)0x0088;
	// ### 	sub.x			vf00,		wakescale,	wakescale[z]
	DoFMSETX(vf0, wakescale - wakescale.Z());
	// ### 	fmand					LL0058,		LL0059
	ll0058 = FM & ll0059;
	// ### 	ibne					LL0058,		vi00,					GY_DontMakeNormal1
	if(ll0058 != 0) 
	{ 
		gy_dontmakenormal1(vumem,xtop,xitop); 
		return; 
	}
	// ### 	div			Q,						oneminusy[x],			wakelensq[x]
	Q = oneminusy.X() / wakelensq.X();
	// ### 	mul.w			temp,					vf00,						Q
	DoFMSETW(tempv, vf0 * Q);
	// ### 	sqrt			Q,						temp[w]
	Q = Math::Sqrt(tempv.W());
	// ### 	mul.xy		temp,					wakediff,				Q
	DoFMSETXY(tempv, wakediff * Q);
	// ### 	sub.x			wakenormal,			vf00,						temp[x]
	DoFMSETX(wakenormal, - tempv.X());
	// ### 	sub.z			wakenormal,			vf00,						temp[y]
	DoFMSETZ(wakenormal, - tempv.Y());
	// ### 	add.y			wakenormal,			vf00,						wakedistscale[x]
	DoFMSETY(wakenormal, + wakedistscale.X());
	// ### 	mul.xz		wakenormal,			wakenormal,				wakescale[x]
	DoFMSETXZ(wakenormal, wakenormal * wakescale.X());
	// ### 	add.xyz		totalwakenormal,	totalwakenormal,		wakenormal
	DoFMSETXYZ(totalwakenormal, totalwakenormal + wakenormal);
	// ### 	iaddiu				hasnormal,	vi00,					1
	hasnormal = 0 + (unsigned)1;
	// ### GY_DontMakeNormal1:
	gy_dontmakenormal1(vumem,xtop,xitop);
}
static void gy_dontmakenormal1(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				LL005b,	vi00,					0x0022
	ll005b = 0 + (unsigned)0x0022;
	// ### 	sub.z			vf00,		wakescale,	totalwakescale
	DoFMSETZ(vf0, wakescale - totalwakescale);
	// ### 	fmand					LL005a,		LL005b
	ll005a = FM & ll005b;
	// ### 	ibne					LL005a,		vi00,					GY_DontMakeNormal2
	if(ll005a != 0) 
	{ 
		gy_dontmakenormal2(vumem,xtop,xitop); 
		return;
	}
	// ### 	div			Q,						oneminusy[z],			wakelensq[z]
	Q = oneminusy.Z() / wakelensq.Z();
	// ### 	mul.w			temp,					vf00,						Q
	DoFMSETW(tempv, vf0 * Q);
	// ### 	sqrt			Q,						temp[w]
	Q = Math::Sqrt(tempv.W());
	// ### 	mul.zw		temp,					wakediff,				Q
	DoFMSETZW(tempv, wakediff * Q);
	// ### 	sub.x			wakenormal,			vf00,						temp[z]
	DoFMSETX(wakenormal,- tempv.Z());
	// ### 	sub.z			wakenormal,			vf00,						temp[w]
	DoFMSETZ(wakenormal,- tempv.W());
	// ### 	add.y			wakenormal,			vf00,						wakedistscale[z]
	DoFMSETY(wakenormal, + wakedistscale.Z());
	// ### 	mul.xz		wakenormal,			wakenormal,				wakescale[z]
	DoFMSETXZ(wakenormal, wakenormal * wakescale.Z());
	// ### 	add.xyz		totalwakenormal,	totalwakenormal,		wakenormal
	DoFMSETXYZ(totalwakenormal, totalwakenormal + wakenormal);
	// ### 	iaddiu				hasnormal,	vi00,					1
	hasnormal = 0 + (unsigned)1;
	// ### GY_DontMakeNormal2:
	gy_dontmakenormal2(vumem,xtop,xitop);
}
static void gy_dontmakenormal2(Vector4* vumem, short xtop, short xitop)
{
	// ### 	max.xz		totalwakescale,	totalwakescale,		wakescale
	totalwakescale.XZ(Vector4::Max(totalwakescale, wakescale));
	// ### 	ibne					counter,		vi00,					GY_WAKE_LOOP
	if(counter != 0) 
	{ 
		gy_wake_loop(vumem,xtop,xitop); 
		return; 
	}
	// ### 	ibeq					hasnormal,		vi00,					GY_SkipWakeNormal
	if(hasnormal == 0) 
	{ 
		gy_skipwakenormal(vumem,xtop,xitop); 
		return; 
	}
	// ### 	mul.xyz				LL005e,		totalwakenormal,				totalwakenormal
	DoFMSETXYZ(ll005e, totalwakenormal.Diag(totalwakenormal));
	// ### 	max.xyzw				LL005c,	   vf00,				vf00[w]
	ll005c.Set(1.0f, 1.0f, 1.0f, 1.0f);
	// ### 	add					ACC,			VF00,				LL005e[x]
	DoFMSET(acc, vf0 + ll005e.X());
	// ### 	madd					ACC,			LL005c,				LL005e[y]
	DoFMSET(acc, acc + ll005c * ll005e.Y());
	// ### 	madd					LL005d,			LL005c,				LL005e[z]
	DoFMSET(ll005d, acc + ll005c * ll005e.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL005d[x]
	Q = Math::Sqrt(1.0f / ll005d.X());
	// ### 	mul.xyz				totalwakenormal,			totalwakenormal,				Q
	DoFMSETXYZ(totalwakenormal, totalwakenormal * Q);
	// ### 	add.xyz		normal,				normal,					totalwakenormal
	DoFMSETXYZ(normal, normal + totalwakenormal);
	// ### GY_SkipWakeNormal:
	gy_skipwakenormal(vumem,xtop,xitop);
}
static void gy_skipwakenormal(Vector4* vumem, short xtop, short xitop)
{
	// ### 	max.x			totalwakescale,	totalwakescale,		totalwakescale[z]
	totalwakescale.X(Vector4::Max(totalwakescale,Vector4(totalwakescale.Z(),totalwakescale.Z(),totalwakescale.Z(),totalwakescale.Z())));

	// ### 	add.y			vtx,					vtx,						totalwakescale[x]
	DoFMSETY(vtxv, vtxv + totalwakescale.X());
	// ### GY_SkipWakes:
	gy_skipwakes(vumem,xtop,xitop);
}
static void gy_skipwakes(Vector4* vumem, short xtop, short xitop)
{
	// ### 	loi 16.0
	I = 16.0;
	// ### 	mul.xz		grid16,				vtx,						I
	DoFMSETXZ(grid16, vtxv * I);
	// ### 	ftoi0.xz		Fi,					grid16
	fi.XZ(Math::IntAsFloat((int)(grid16.x()*(1<<0))), Math::IntAsFloat((int)(grid16.z()*(1<<0))));
	// ### 	itof0.xz		F,						Fi
	f.XZ((float)Math::FloatAsInt(fi.x())/(1<<0),(float)Math::FloatAsInt(fi.z())/(1<<0));
	// ### 	sub.xz		weighth,				grid16,					F
	DoFMSETXZ(weighth, grid16 - f);
	// ### 	sub.xz		weightl,				ones,						weighth
	DoFMSETXZ(weightl, ones - weighth);
	// ### 	sub.x			a,						F,							vf00[w]
	DoFMSETX(a, f - 1.0f);
	// ### 	move.z		a,						F
	a.Z(f);
	// ### 	loi			0.25
	I = 0.25;
	// ### 	mul.z			subqword,			a,							I
	DoFMSETZ(subqword, a * I);
	// ### 	ftoi0.z		subqword,			subqword
	subqword.Z(Math::IntAsFloat((int)(subqword.z()*(1<<0))));
	// ### 	itof0.z		subqword,			subqword
	subqword.Z((float)Math::FloatAsInt(subqword.z())/(1<<0));
	// ### 	add.z			ACC,					vf00,						a
//pab	DoFMSETZ(acc, + a);
	DoFMSETZ(acc, a);
	// ### 	loi			4.0
	I = 4.0;
	// ### 	msub.z		ptr,					subqword,				I
	DoFMSETZ(ptr, acc - subqword * I);
	// ### 	loi			5.0
	I = 5.0;
	// ### 	add.x			ACC,					vf00,						subqword[z]
	DoFMSETX(acc, + subqword.Z());
	// ### 	madd.x		ptr,					a,							I
	DoFMSETX(ptr, acc + a * I);
	// ### 	ftoi0.xz		ptr,					ptr
	ptr.XZ(Math::IntAsFloat((int)(ptr.x()*(1<<0))), Math::IntAsFloat((int)(ptr.z()*(1<<0))));
	// ### 	mtir			field,				ptr[z]
	field = (unsigned short)Math::FloatAsInt(ptr.Z());
	// ### 	mtir			qword,				ptr[x]
	qword = (unsigned short)Math::FloatAsInt(ptr.X());
	// ### 	mini.xyzw			valqw[0],		vf00,				vf00[x]
	valqw[0].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw[2],		vf00,				vf00[x]
	valqw[2].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw[3],		vf00,				vf00[x]
	valqw[3].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	ibltz			qword,				GY_SkipPlus0
	if(qword < 0) 
	{ 
		gy_skipplus0(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lq				valqw[0],			180(qword)
	valqw[0].Set(vumem[180 + qword]);
	// ### GY_SkipPlus0:
	gy_skipplus0(vumem,xtop,xitop);
}
static void gy_skipplus0(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				valqw[1],			180+5(qword)
	valqw[1].Set(vumem[180+5 + qword]);
	// ### 	isubiu				LL005f,			qword,			74
	ll005f = qword - (unsigned)74;
	// ### 	ibgtz					LL005f,			GY_SkipPlus10
	if(ll005f > 0) 
	{ 
		gy_skipplus10(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lq				valqw[2],			180+10(qword)
	valqw[2].Set(vumem[180+10 + qword]);
	// ### 	isubiu				LL0060,			qword,			69
	ll0060 = qword - (unsigned)69;
	// ### 	ibgtz					LL0060,			GY_SkipPlus15
	if(ll0060 > 0) 
	{ 
		gy_skipplus15(vumem,xtop,xitop); 
		return;
	}
	// ### 	lq				valqw[3],			180+15(qword)
	valqw[3].Set(vumem[180+15 + qword]);
	// ### GY_SkipPlus10:
	gy_skipplus10(vumem,xtop,xitop);
}
static void gy_skipplus10(Vector4* vumem, short xtop, short xitop)
{
	// ### GY_SkipPlus15:
	gy_skipplus15(vumem,xtop,xitop);
}
static void gy_skipplus15(Vector4* vumem, short xtop, short xitop)
{
	// ### 	ibeq					field,		vi00,					GY_Field0
	if(field == 0) 
	{ 
		gy_field0(vumem,xtop,xitop);
		return;
	}
	// ### 	isubiu				field,	field,				1
	field = field - (unsigned)1;
	// ### 	ibeq					field,		vi00,					GY_HaveFields
	if(field == 0) 
	{ 
		gy_havefields(vumem,xtop,xitop);
		return;
	}
	// ### 	mini.xyzw			valqw1[0],		vf00,				vf00[x]
	valqw1[0].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw1[2],		vf00,				vf00[x]
	valqw1[2].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw1[3],		vf00,				vf00[x]
	valqw1[3].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	ibltz			qword,				GY_SkipPlus1
	if(qword < 0) 
	{ 
		gy_skipplus1(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lq				valqw1[0],			180+1(qword)
	valqw1[0].Set(vumem[180+1 + qword]);
	// ### GY_SkipPlus1:
	gy_skipplus1(vumem,xtop,xitop);
}
static void gy_skipplus1(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				valqw1[1],			180+6(qword)
	valqw1[1].Set(vumem[180+6 + qword]);
	// ### 	isubiu				LL0061,			qword,			73
	ll0061 = qword - (unsigned)73;
	// ### 	ibgtz					LL0061,			GY_SkipPlus11
	if(ll0061 > 0) 
	{ 
		gy_skipplus11(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lq				valqw1[2],			180+11(qword)
	valqw1[2].Set(vumem[180+11 + qword]);
	// ### 	isubiu				LL0062,			qword,			68
	ll0062 = qword - (unsigned)68;
	// ### 	ibgtz					LL0062,			GY_SkipPlus16
	if(ll0062 > 0) 
	{ 
		gy_skipplus16(vumem,xtop,xitop);
		return;
	}
	// ### 	lq				valqw1[3],			180+16(qword)
	valqw1[3].Set(vumem[180+16 + qword]);
	// ### GY_SkipPlus11:
	gy_skipplus11(vumem,xtop,xitop);
}
static void gy_skipplus11(Vector4* vumem, short xtop, short xitop)
{
	// ### GY_SkipPlus16:
	gy_skipplus16(vumem,xtop,xitop);
}
static void gy_skipplus16(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				field,	field,				1
	field = field - (unsigned)1;
	// ### 	ibeq					field,		vi00,					GY_Field2
	if(field == 0) 
	{ 
		gy_field2(vumem,xtop,xitop); 
		return;
	}
	// ### GY_Field3:
	gy_field3(vumem,xtop,xitop);
}
static void gy_field3(Vector4* vumem, short xtop, short xitop)
{
	// ### 	move.xy		valqw[0],			valqw1[0]
	valqw[0].XY(valqw1[0]);
	// ### 	move.xy		valqw[1],			valqw1[1]
	valqw[1].XY(valqw1[1]);
	// ### 	move.xy		valqw[2],			valqw1[2]
	valqw[2].XY(valqw1[2]);
	// ### 	move.xy		valqw[3],			valqw1[3]
	valqw[3].XY(valqw1[3]);
	// ### GY_Field3_Rotate:
	gy_field3_rotate(vumem,xtop,xitop);
}
static void gy_field3_rotate(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mr32			valqw[0],			valqw[0]
	valqw[0].Set(valqw[0].RotateLeft());
	// ### 	mr32			valqw[1],			valqw[1]
	valqw[1].Set(valqw[1].RotateLeft());
	// ### 	mr32			valqw[2],			valqw[2]
	valqw[2].Set(valqw[2].RotateLeft());
	// ### 	mr32			valqw[3],			valqw[3]
	valqw[3].Set(valqw[3].RotateLeft());
	// ### 	b				GY_Field2_Rotate
	gy_field2_rotate(vumem,xtop,xitop);
	return;
}
static void gy_field0(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mini.xyzw			valqw1[0],		vf00,				vf00[x]
	valqw1[0].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw1[1],		vf00,				vf00[x]
	valqw1[1].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw1[2],		vf00,				vf00[x]
	valqw1[2].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			valqw1[3],		vf00,				vf00[x]
	valqw1[3].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	ibltz			qword,				GY_SkipMinus1
	if(qword < 0) 
	{ 
		gy_skipminus1(vumem,xtop,xitop);
		return;
	}
	// ### 	iblez			qword,				GY_SkipPlus4
	if(qword <= 0) 
	{ 
		gy_skipplus4(vumem,xtop,xitop);
		return;
	}
	// ### 	lq				valqw1[0],			180-1(qword)
	valqw1[0].Set(vumem[180-1 + qword]);
	// ### GY_SkipMinus1:
	gy_skipminus1(vumem,xtop,xitop);
}
static void gy_skipminus1(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				valqw1[1],			180+4(qword)
	valqw1[1].Set(vumem[180+4 + qword]);
	// ### GY_SkipPlus4:
	gy_skipplus4(vumem,xtop,xitop);
}
static void gy_skipplus4(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				LL0063,			qword,			75
	ll0063 = qword - (unsigned)75;
	// ### 	ibgtz					LL0063,			GY_SkipPlus9
	if(ll0063 > 0) 
	{ 
		gy_skipplus9(vumem,xtop,xitop); 
		return;
	}
	// ### 	lq				valqw1[2],			180+9(qword)
	valqw1[2].Set(vumem[180+9 + qword]);
	// ### 	isubiu				LL0064,			qword,			70
	ll0064 = qword - (unsigned)70;
	// ### 	ibgtz					LL0064,			GY_SkipPlus14
	if(ll0064 > 0) 
	{ 
		gy_skipplus14(vumem,xtop,xitop); 
		return;
	}
	// ### 	lq				valqw1[3],			180+14(qword)
	valqw1[3].Set(vumem[180+14 + qword]);
	// ### GY_SkipPlus9:
	gy_skipplus9(vumem,xtop,xitop);
}
static void gy_skipplus9(Vector4* vumem, short xtop, short xitop)
{
	// ### GY_SkipPlus14:
	gy_skipplus14(vumem,xtop,xitop);
}
static void gy_skipplus14(Vector4* vumem, short xtop, short xitop)
{
	// ### 	move.w		valqw[0],			valqw1[0]
	valqw[0].W(valqw1[0]);
	// ### 	move.w		valqw[1],			valqw1[1]
	valqw[1].W(valqw1[1]);
	// ### 	move.w		valqw[2],			valqw1[2]
	valqw[2].W(valqw1[2]);
	// ### 	move.w		valqw[3],			valqw1[3]
	valqw[3].W(valqw1[3]);
	// ### 	mr32			valqw[0],			valqw[0]
	valqw[0].Set(valqw[0].RotateLeft());
	// ### 	mr32			valqw[1],			valqw[1]
	valqw[1].Set(valqw[1].RotateLeft());
	// ### 	mr32			valqw[2],			valqw[2]
	valqw[2].Set(valqw[2].RotateLeft());
	// ### 	mr32			valqw[3],			valqw[3]
	valqw[3].Set(valqw[3].RotateLeft());
	// ### 	b				GY_Field3_Rotate
	gy_field3_rotate(vumem,xtop,xitop);
	return;
}
static void gy_field2(Vector4* vumem, short xtop, short xitop)
{
	// ### 	move.x		valqw[0],			valqw1[0]
	valqw[0].X(valqw1[0]);
	// ### 	move.x		valqw[1],			valqw1[1]
	valqw[1].X(valqw1[1]);
	// ### 	move.x		valqw[2],			valqw1[2]
	valqw[2].X(valqw1[2]);
	// ### 	move.x		valqw[3],			valqw1[3]
	valqw[3].X(valqw1[3]);
	// ### GY_Field2_Rotate:
	gy_field2_rotate(vumem,xtop,xitop);
}
static void gy_field2_rotate(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mr32			valqw[0],			valqw[0]
	valqw[0].Set(valqw[0].RotateLeft());
	// ### 	mr32			valqw[1],			valqw[1]
	valqw[1].Set(valqw[1].RotateLeft());
	// ### 	mr32			valqw[2],			valqw[2]
	valqw[2].Set(valqw[2].RotateLeft());
	// ### 	mr32			valqw[3],			valqw[3]
	valqw[3].Set(valqw[3].RotateLeft());
	// ### GY_HaveFields:
	gy_havefields(vumem,xtop,xitop);
}
static void gy_havefields(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.x			weightll,			weightl,					weightl[z]
	DoFMSETX(weightll, weightl * weightl.Z());
	// ### 	mul.x			weightlh,			weightl,					weighth[z]
	DoFMSETX(weightlh, weightl * weighth.Z());
	// ### 	mul.x			weighthl,			weighth,					weightl[z]
	DoFMSETX(weighthl, weighth * weightl.Z());
	// ### 	mul.x			weighthh,			weighth,					weighth[z]
	DoFMSETX(weighthh, weighth * weighth.Z());
	// ### 	iaddiu				twofiftyfive,	vi00,					0xFF
	twofiftyfive = 0 + (unsigned)0xff;
	// ### 	mtir			damp,					valqw[1][y]
	damp = (unsigned short)Math::FloatAsInt(valqw[1].Y());
	// ### 	iand			damp,					damp,						twofiftyfive
	damp = damp & twofiftyfive;
	// ### 	mfir.x		dampf,				damp
	dampf.X(Math::IntAsFloat(damp));
	// ### 	mtir			damp,					valqw[1][z]
	damp = (unsigned short)Math::FloatAsInt(valqw[1].Z());
	// ### 	iand			damp,					damp,						twofiftyfive
	damp = damp & twofiftyfive;
	// ### 	mfir.y		dampf,				damp
	dampf.Y(Math::IntAsFloat(damp));
	// ### 	mtir			damp,					valqw[2][y]
	damp = (unsigned short)Math::FloatAsInt(valqw[2].Y());
	// ### 	iand			damp,					damp,						twofiftyfive
	damp = damp & twofiftyfive;
	// ### 	mfir.z		dampf,				damp
	dampf.Z(Math::IntAsFloat(damp));
	// ### 	mtir			damp,					valqw[2][z]
	damp = (unsigned short)Math::FloatAsInt(valqw[2].Z());
	// ### 	iand			damp,					damp,						twofiftyfive
	damp = damp & twofiftyfive;
	// ### 	mfir.w		dampf,				damp
	dampf.W(Math::IntAsFloat(damp));
	// ### 	itof0			dampf,				dampf
	dampf.Set((float)Math::FloatAsInt(dampf.x())/(1<<0),(float)Math::FloatAsInt(dampf.y())/(1<<0),(float)Math::FloatAsInt(dampf.z())/(1<<0),(float)Math::FloatAsInt(dampf.w())/(1<<0));
	// ### 	mul.x			ACC,					weightll,				dampf[x]
	DoFMSETX(acc, weightll * dampf.X());
	// ### 	madd.x		ACC,					weightlh,				dampf[y]
	DoFMSETX(acc, acc + weightlh * dampf.Y());
	// ### 	madd.x		ACC,					weighthl,				dampf[z]
	DoFMSETX(acc, acc + weighthl * dampf.Z());
	// ### 	madd.x		dampval,				weighthh,				dampf[w]
	DoFMSETX(dampval, acc + weighthh * dampf.W());
	// ### 	mul.x			ACC,					weightll,				valqw[1][y]
	DoFMSETX(acc, weightll * valqw[1].Y());
	// ### 	madd.x		ACC,					weightlh,				valqw[1][z]
	DoFMSETX(acc, acc + weightlh * valqw[1].Z());
	// ### 	madd.x		ACC,					weighthl,				valqw[2][y]
	DoFMSETX(acc, acc + weighthl * valqw[2].Y());
	// ### 	madd.x		physicsheight,		weighthh,				valqw[2][z]
	DoFMSETX(physicsheight, acc + weighthh * valqw[2].Z());
	// ### 	add.y			vtx,					vtx,						physicsheight[x]
	DoFMSETY(vtxv, vtxv + physicsheight.X());
	// ### 	sub.x			N1,					valqw[2],				valqw[2][z]	
	DoFMSETX(n1, valqw[2] - valqw[2].Z());
	// ### 	sub.y			N2,					valqw[2],				valqw[2][w] 
	DoFMSETY(n2, valqw[2] - valqw[2].W());
	// ### 	sub.x			N3,					valqw[1],				valqw[1][z]	
	DoFMSETX(n3, valqw[1] - valqw[1].Z());
	// ### 	sub.y			N4,					valqw[1],				valqw[1][w]	
	DoFMSETY(n4, valqw[1] - valqw[1].W());
	// ### 	sub.y			N1,					valqw[1],				valqw[3]	
	DoFMSETY(n1, valqw[1] - valqw[3]);
	// ### 	sub.z			N2,					valqw[1],				valqw[3]	
	DoFMSETZ(n2, valqw[1] - valqw[3]);
	// ### 	sub.y			N3,					valqw[0],				valqw[2]	
	DoFMSETY(n3, valqw[0] - valqw[2]);
	// ### 	sub.z			N4,					valqw[0],				valqw[2]	
	DoFMSETZ(n4, valqw[0] - valqw[2]);
	// ### 	mr32.xy		N2,					N2
	n2.XY(n2.RotateLeft());
	// ### 	mr32.xy		N4,					N4
	n4.XY(n4.RotateLeft());
	// ### 	mul.xy		ACC,					N1,						weighthl[x]
	DoFMSETXY(acc, n1 * weighthl.X());
	// ### 	madd.xy		ACC,					N2,						weighthh[x]
	DoFMSETXY(acc, acc + n2 * weighthh.X());
	// ### 	madd.xy		ACC,					N3,						weightll[x]
	DoFMSETXY(acc, acc + n3 * weightll.X());
	// ### 	madd.xy		phynormal,			N4,						weightlh[x]
	DoFMSETXY(phynormal, acc + n4 * weightlh.X());
	// ### 	mul.z			phynormal,			ones,						phynormal[x]
	DoFMSETZ(phynormal, ones * phynormal.X());
	// ### 	mul.x			phynormal,			ones,						phynormal[y]
	DoFMSETX(phynormal, ones * phynormal.Y());
	// ### 	loi			2.0
	I = 2.0;
	// ### 	mul.xz		phynormal,			phynormal,				I
	DoFMSETXZ(phynormal, phynormal * I);
	// ### 	add.x			ACC,					vf00,						vf00[w]
	DoFMSETX(acc, + 1.0f);
	// ### 	msub.x		ACC,					phynormal,				phynormal
	DoFMSETX(acc, acc - phynormal.Diag(phynormal));
	// ### 	add.x			temp,					vf00,						phynormal[z]
	DoFMSETX(tempv, + phynormal.Z());
	// ### 	msub.x		ysq,					temp,						temp
	DoFMSETX(ysq, acc - tempv.Diag(tempv));
	// ### 	sqrt			Q,						ysq[x]
	Q = Math::Sqrt(ysq.X());
	// ### 	add.y			phynormal,			vf00,						Q
	DoFMSETY(phynormal, + Q);
	// ### 	loi			0x3B808081		  
	I = Math::IntAsFloat(0x3b808081);
	// ### 	mul.w			dampval,				vf00,						dampval[x]
	DoFMSETW(dampval, vf0 * dampval.X());
	// ### 	muli.w		normal,				dampval,					I
	DoFMSETW(normal, dampval * I);
	// ### 	add.xyz		normal,				normal,					phynormal
	DoFMSETXYZ(normal, normal + phynormal);
	// ### 	lq				noise[0],			0(vi00)
	noise[0].Set(vumem[0 + 0]);
	// ### 	lq				noise[1],			4(vi00)
	noise[1].Set(vumem[4 + 0]);
	// ### 	mr32			noise[1],			noise[1]
	noise[1].Set(noise[1].RotateLeft());
	// ### 	loi			2.0
	I = 2.0;
	// ### 	mul			twos,					ones,						I
	DoFMSET(twos, ones * I);
	// ### 	move			onetwothree,		ones
	onetwothree.Set(ones);
	// ### 	add.xw		onetwothree,		onetwothree,			vf00[w]
	DoFMSETXW(onetwothree, onetwothree + 1.0f);
	// ### 	add.w			onetwothree,		onetwothree,			vf00[w]
	DoFMSETW(onetwothree, onetwothree + 1.0f);
	// ### 	mul.xz		scaled,				offsetvtx,				noise[1]
	DoFMSETXZ(scaled, offsetvtx.Diag(noise[1]));
	// ### 	mul.w			masterT,				mT,						noise[0]
	DoFMSETW(mastert, mt.Diag(noise[0]));
	// ### 	add.w			masterTx,			masterT,					scaled[x]
	DoFMSETW(mastertx, mastert + scaled.X());
	// ### 	ftoi0.w		txi,					masterTx
	txi.W(Math::IntAsFloat((int)(mastertx.w()*(1<<0))));
	// ### 	itof0.w		tx,					txi
	tx.W((float)Math::FloatAsInt(txi.w())/(1<<0));
	// ### 	add.w			masterTz,			masterT,					scaled[z]
	DoFMSETW(mastertz, mastert + scaled.Z());
	// ### 	loi			0x3F700000 
	I = Math::IntAsFloat(0x3f700000);
	// ### 	mul.w			masterTz,			masterTz,				I
	DoFMSETW(mastertz, mastertz * I);
	// ### 	ftoi0.w		tzi,					masterTz
	tzi.W(Math::IntAsFloat((int)(mastertz.w()*(1<<0))));
	// ### 	itof0.w		tz,					tzi
	tz.W((float)Math::FloatAsInt(tzi.w())/(1<<0));
	// ### 	sub.w			mx,					masterTx,				tx
	DoFMSETW(mx, mastertx - tx);
	// ### 	mr32.z		mx,					mx
	mx.Z(mx.RotateLeft());
	// ### 	sub.xyw		mx,					onetwothree,			mx[z]
	DoFMSETXYW(mx, onetwothree - mx.Z());
	// ### 	sub.w			mz,					masterTz,				tz
	DoFMSETW(mz, mastertz - tz);
	// ### 	mr32.z		mz,					mz
	mz.Z(mz.RotateLeft());
	// ### 	sub.xyw		mz,					onetwothree,			mz[z]
	DoFMSETXYW(mz, onetwothree - mz.Z());
	// ### 	iaddiu				fifteen,	vi00,					0x0F
	fifteen = 0 + (unsigned)0x0f;
	// ### 	mtir			idx,					txi[w]
	idx = (unsigned short)Math::FloatAsInt(txi.W());
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.x			b0,					163(idx)
	b0.X(vumem[163 + idx]);
	// ### 	iaddiu		idx,					idx,						1
	idx = idx + (unsigned)1;
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.x			b1,					163(idx)
	b1.X(vumem[163 + idx]);
	// ### 	iaddiu		idx,					idx,						1
	idx = idx + (unsigned)1;
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.x			b2,					163(idx)
	b2.X(vumem[163 + idx]);
	// ### 	mtir			idx,					tzi[w]
	idx = (unsigned short)Math::FloatAsInt(tzi.W());
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.y			b0,					163(idx)
	b0.Y(vumem[163 + idx]);
	// ### 	iaddiu		idx,					idx,						1
	idx = idx + (unsigned)1;
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.y			b1,					163(idx)
	b1.Y(vumem[163 + idx]);
	// ### 	iaddiu		idx,					idx,						1
	idx = idx + (unsigned)1;
	// ### 	iand			idx,					idx,						fifteen
	idx = idx & fifteen;
	// ### 	lq.y			b2,					163(idx)
	b2.Y(vumem[163 + idx]);
	// ### 	mul.w			xval,					mx,						b0[x]
	DoFMSETW(xval, mx * b0.X());
	// ### 	mul.x			xval,					mx,						b1[x]
	DoFMSETX(xval, mx * b1.X());
	// ### 	mul.y			xval,					mx,						b2[x]
	DoFMSETY(xval, mx * b2.X());
	// ### 	mul.w			zval,					mz,						b0[y]
	DoFMSETW(zval, mz * b0.Y());
	// ### 	mul.x			zval,					mz,						b1[y]
	DoFMSETX(zval, mz * b1.Y());
	// ### 	mul.y			zval,					mz,						b2[y]
	DoFMSETY(zval, mz * b2.Y());
	// ### 	sub.w			val,					xval,						xval[y]
	DoFMSETW(val, xval - xval.Y());
	// ### 	mul.w			ACC,					vf00,						xval[x]
	DoFMSETW(acc, vf0 * xval.X());
	// ### 	loi			0.5
	I = 0.5;
	// ### 	msub.w		val,					val,						I
	DoFMSETW(val, acc - val * I);
	// ### 	mul.w			ACC,					vf00,						b0[x]
	DoFMSETW(acc, vf0 * b0.X());
	// ### 	madd.w		xval,					val,						mx[z]
	DoFMSETW(xval, acc + val * mx.Z());
	// ### 	sub.w			val,					zval,						zval[y]
	DoFMSETW(val, zval - zval.Y());
	// ### 	mul.w			ACC,					vf00,						zval[x]
	DoFMSETW(acc, vf0 * zval.X());
	// ### 	loi			0.5
	I = 0.5;
	// ### 	msub.w		val,					val,						I
	DoFMSETW(val, acc - val * I);
	// ### 	mul.w			ACC,					vf00,						b0[y]
	DoFMSETW(acc, vf0 * b0.Y());
	// ### 	madd.w		zval,					val,						mz[z]
	DoFMSETW(zval, acc + val * mz.Z());
	// ### 	mul.w			val,					xval,						zval
	DoFMSETW(val, xval.Diag(zval));
	// ### 	add.y			ACC,					vf00,						vtx
//pab	DoFMSETY(acc, + vtx);
	DoFMSETY(acc, vtxv);
	// ### 	madd.y		vtx,					noise[0],				val[w]
	DoFMSETY(vtxv, acc + noise[0] * val.W());
	// ### 	sub.xy		slope0,				b1,						b0
	DoFMSETXY(slope0, b1 - b0);
	// ### 	sub.xy		slope1,				b2,						b1
	DoFMSETXY(slope1, b2 - b1);
	// ### 	mul.x			slope0,				slope0,					mx[y]
	DoFMSETX(slope0, slope0 * mx.Y());
	// ### 	mul.x			slope1,				slope1,					mx[z]
	DoFMSETX(slope1, slope1 * mx.Z());
	// ### 	mul.y			slope0,				slope0,					mz[y]
	DoFMSETY(slope0, slope0 * mz.Y());
	// ### 	mul.y			slope1,				slope1,					mz[z]
	DoFMSETY(slope1, slope1 * mz.Z());
	// ### 	add.xy		n,						slope0,					slope1
	DoFMSETXY(n, slope0 + slope1);
	// ### 	mul.xy		n,						n,							noise[0][y]
	DoFMSETXY(n, n * noise[0].Y());
	// ### 	add.z			n,						vf00,						n[y]
	DoFMSETZ(n, + n.Y());
	// ### 	loi			4.0
	I = 4.0;
	// ### 	add.y			n,						vf00,						I
	DoFMSETY(n, + I);
	// ### 	mul.xyz				LL0067,		n,				n
	DoFMSETXYZ(ll0067, n.Diag(n));
	// ### 	max.xyzw				LL0065,	   vf00,				vf00[w]
	ll0065.Set(1.0f,1.0f,1.0f,1.0f);
	// ### 	add					ACC,			VF00,				LL0067[x]
	DoFMSET(acc, vf0 + ll0067.X());
	// ### 	madd					ACC,			LL0065,				LL0067[y]
	DoFMSET(acc, acc + ll0065 * ll0067.Y());
	// ### 	madd					LL0066,			LL0065,				LL0067[z]
	DoFMSET(ll0066, acc + ll0065 * ll0067.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0066[x]
	Q = Math::Sqrt(1.0f / ll0066.X());
	// ### 	mul.xyz				n,			n,				Q
	DoFMSETXYZ(n, n * Q);
	// ### 	add.xyz		normal,				normal,					n
	DoFMSETXYZ(normal, normal + n);
	// ### 	mul.y			vtx,					vtx,						normal[w]
	DoFMSETY(vtxv, vtxv * normal.W());
	// ### 	add.y			vtx,					vtx,						miscqw24
	DoFMSETY(vtxv, vtxv + miscqw24);
	// ### 	mul.xyz				LL006a,		normal,				normal
	DoFMSETXYZ(ll006a, normal.Diag(normal));
	// ### 	max.xyzw				LL0068,	   vf00,				vf00[w]
	ll0068.Set(1.0f,1.0f,1.0f,1.0f);
	// ### 	add					ACC,			VF00,				LL006a[x]
	DoFMSET(acc, vf0 + ll006a.X());
	// ### 	madd					ACC,			LL0068,				LL006a[y]
	DoFMSET(acc, acc + ll0068 * ll006a.Y());
	// ### 	madd					LL0069,			LL0068,				LL006a[z]
	DoFMSET(ll0069, acc + ll0068 * ll006a.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0069[x]
	Q = Math::Sqrt(1.0f / ll0069.X());
	// ### 	mul.xyz				normal,			normal,				Q
	DoFMSETXYZ(normal, normal * Q);
	// ### 	b				ReturnFromGetY
	returnfromgety(vumem,xtop,xitop);
	return;
}
static void rendermultipass(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq    mScreenToClip[0], 17+0(vi00)
	mscreentoclip[0].Set(vumem[17+0 + 0]);
	// ### 	lq    mScreenToClip[1], 17+1(vi00)
	mscreentoclip[1].Set(vumem[17+1 + 0]);
	// ### 	lq    mScreenToClip[2], 17+2(vi00)
	mscreentoclip[2].Set(vumem[17+2 + 0]);
	// ### 	lq		mScreenToClip[3], 17+3(vi00)
	mscreentoclip[3].Set(vumem[17+3 + 0]);
	// ### 	iaddiu				layer,	vi00,					1
	layer = 0 + (unsigned)1;
	// ### 	ilw.y			numLayers,			133(vi00)
	numlayers = Math::FloatAsInt(vumem[133 + 0].y());
	// ### 	iaddiu				LL006b,	vi00,					0xFF
	ll006b = 0 + (unsigned)0xff;
	// ### 	iand					numLayers,	numLayers,					LL006b
	numlayers = numlayers & ll006b;
	// ### 	ibeq			layer,				numLayers,				RMP_DoneWithLayers
	if(layer == numlayers) 
	{ 
		rmp_donewithlayers(vumem,xtop,xitop);
		return; 
	}
	// ### RMP_NextLayer:
	rmp_nextlayer(vumem,xtop,xitop);
}
static void rmp_nextlayer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layer4,				layer2,					layer2
	layer4 = layer2 + (unsigned)layer2;
	// ### 	iadd			layer6,				layer4,					layer2
	layer6 = layer4 + (unsigned)layer2;
	// ### 	lq				layer[0],			133+0(layer6)
	layerv[0].Set(vumem[133+0 + layer6]);
	// ### 	lq				layer[3],			133+3(layer6)
	layerv[3].Set(vumem[133+3 + layer6]);
	// ### 	lq				layer[4],			133+4(layer6)
	layerv[4].Set(vumem[133+4 + layer6]);
	// ### 	lq				layer[5],			133+5(layer6)
	layerv[5].Set(vumem[133+5 + layer6]);
	// ### 	mini.yzw			mTexMatrix[0],	   vf00,				vf00[x]
	mtexmatrix[0].YZW(0.0f,0.0f,0.0f);
	// ### 	mini.xyzw			mTexMatrix[1],	   vf00,				vf00[x]
	mtexmatrix[1].Set(0.0f,0.0f,0.0f,0.0f);
	// ### 	mini.xzw			mTexMatrix[2],	   vf00,				vf00[x]
	mtexmatrix[2].XZW(0.0f,0.0f,0.0f);
	// ### 	move.x		mTexMatrix[0],		layer[0]
	mtexmatrix[0].X(layerv[0]);
	// ### 	move.y		mTexMatrix[2],		layer[0]
	mtexmatrix[2].Y(layerv[0]);
	// ### 	lq.w			mT,					1(vi00)
	mt.W(vumem[1 + 0]);
	// ### 	mr32.xyzw	rotlayer,			layer[0]
	rotlayer.Set(layerv[0].RotateLeft());
	// ### 	mr32.xyzw	rotlayer,			rotlayer
	rotlayer.Set(rotlayer.RotateLeft());
	// ### 	mul.xy		mTexMatrix[3],		rotlayer,				mT[w]
	DoFMSETXY(mtexmatrix[3], rotlayer * mt.W());
	// ### 	mini.z			mTexMatrix[3],	   vf00,				vf00[x]
	mtexmatrix[3].Z(0.0f);
	// ### 	max.w				mTexMatrix[3],		vf00,				vf00[w]
	mtexmatrix[3].W(1.0f);
	// ### 	ftoi15.xy	mTexMatrix[3],		mTexMatrix[3]
	mtexmatrix[3].XY(Math::IntAsFloat((int)(mtexmatrix[3].x()*(1<<15))), Math::IntAsFloat((int)(mtexmatrix[3].y()*(1<<15))));
	// ### 	mtir			clampme,				mTexMatrix[3][x]
	clampme = (unsigned short)Math::FloatAsInt(mtexmatrix[3].X());
	// ### 	mfir.x		mTexMatrix[3],		clampme
	mtexmatrix[3].X(Math::IntAsFloat(clampme));
	// ### 	mtir			clampme,				mTexMatrix[3][y]
	clampme = (unsigned short)Math::FloatAsInt(mtexmatrix[3].Y());
	// ### 	mfir.y		mTexMatrix[3],		clampme
	mtexmatrix[3].Y(Math::IntAsFloat(clampme));
	// ### 	itof15.xy	mTexMatrix[3],		mTexMatrix[3]
	mtexmatrix[3].XY((float)Math::FloatAsInt(mtexmatrix[3].x())/(1<<15),(float)Math::FloatAsInt(mtexmatrix[3].y())/(1<<15));
	// ### 	mtir			layerFlags,			layer[5][x]
	layerflags = (unsigned short)Math::FloatAsInt(layerv[5].X());
	// ### 	isw.y			layerFlags,			317(vi00)
	vumem[317 + 0].Y(Math::IntAsFloat(layerflags));
	// ### 	mr32.yz		mVtxAdj,				layer[3]
	mvtxadj.YZ(layerv[3].RotateLeft());
	// ### 	mr32.xy		mVtxAdj,				mVtxAdj
	mvtxadj.XY(mvtxadj.RotateLeft());
	// ### 	add.z			mVtxAdj,				vf00,						layer[4][x]
	DoFMSETZ(mvtxadj, + layerv[4].X());
	// ### 	mr32.xyz		mNormAdj,			layer[4]
	mnormadj.XYZ(layerv[4].RotateLeft());
	// ### 	iaddiu				currbuff,	buffcount,					0
	currbuff = buffcount + (unsigned)0;
	// ### RMP_NextBuffer:
	rmp_nextbuffer(vumem,xtop,xitop);
}
static void rmp_nextbuffer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	ilw.x			vtxCount,			7(mKickBuffer[1])	:KICKBUFFER
	vtxcount = Math::FloatAsInt(vumem[7 + mkickbuffer[1]].x());
	// ### 	iaddiu				LL006c,	vi00,					0x7fff
	ll006c = 0 + (unsigned)0x7fff;
	// ### 	iand					vtxCount,	vtxCount,					LL006c
	vtxcount = vtxcount & ll006c;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### 	iaddiu				regcount,	vi00,					6
	regcount = 0 + (unsigned)6;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	lq				LL006f,					3(vi00)
	ll006f.Set(vumem[3 + 0]);
	// ### 	mfir.x		LL006f,					regcount
	ll006f.X(Math::IntAsFloat(regcount | 0x80000000));
	// ### 	sqi			LL006f,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(ll006f);
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layer4,				layer2,					layer2
	layer4 = layer2 + (unsigned)layer2;
	// ### 	iadd			layer6,				layer4,					layer2
	layer6 = layer4 + (unsigned)layer2;
	// ### 	lq				layer[0],			133+0(layer6)
	layerv[0].Set(vumem[133+0 + layer6]);
	// ### 	lq				layer[1],			133+1(layer6)
	layerv[1].Set(vumem[133+1 + layer6]);
	// ### 	lq				layer[2],			133+2(layer6)
	layerv[2].Set(vumem[133+2 + layer6]);
	// ### 	lq				layer[3],			133+3(layer6)
	layerv[3].Set(vumem[133+3 + layer6]);
	// ### 	lq				layer[4],			133+4(layer6)
	layerv[4].Set(vumem[133+4 + layer6]);
	// ### 	mr32			miptbp2,				layer[1]
	miptbp2.Set(layerv[1].RotateLeft());
	// ### 	mr32			miptbp2,				miptbp2
	miptbp2.Set(miptbp2.RotateLeft());
	// ### 	move			miptbp1,				layer[1]
	miptbp1.Set(layerv[1]);
	// ### 	mr32			tex1,					layer[2]
	tex1.Set(layerv[2].RotateLeft());
	// ### 	mr32			tex1,					tex1
	tex1.Set(tex1.RotateLeft());
	// ### 	move			tex0,					layer[2]
	tex0.Set(layerv[2]);
	// ### 	move			clamp,				layer[3]
	clamp.Set(layerv[3]);
	// ### 	mr32			alpha1,				layer[0]
	alpha1.Set(layerv[0].RotateLeft());
	// ### 	mr32			alpha1,				alpha1
	alpha1.Set(alpha1.RotateLeft());
	// ### 	iaddiu				regnum,	vi00,					0x34
	regnum = 0 + (unsigned)0x34;
	// ### 	mfir.z		miptbp1,				regnum
	miptbp1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x36
	regnum = 0 + (unsigned)0x36;
	// ### 	mfir.z		miptbp2,				regnum
	miptbp2.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x6
	regnum = 0 + (unsigned)0x6;
	// ### 	mfir.z		tex0,					regnum
	tex0.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x14
	regnum = 0 + (unsigned)0x14;
	// ### 	mfir.z		tex1,					regnum
	tex1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x8
	regnum = 0 + (unsigned)0x8;
	// ### 	mfir.z		clamp,				regnum
	clamp.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x42
	regnum = 0 + (unsigned)0x42;
	// ### 	mfir.z		alpha1,				regnum
	alpha1.Z(Math::IntAsFloat(regnum));
	// ### 	sqi.xyz		miptbp1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp1);
	// ### 	sqi.xyz		miptbp2,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp2);
	// ### 	sqi.xyz		tex0,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex0);
	// ### 	sqi.xyz		tex1,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex1);
	// ### 	sqi.xyz		clamp,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(clamp);
	// ### 	sqi.xyz		alpha1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(alpha1);
	// ### 	mtir			temp,					alpha1[y]
	temp = (unsigned short)Math::FloatAsInt(alpha1.Y());
	// ### 	iaddiu				LL0070,	vi00,					0xFF
	ll0070 = 0 + (unsigned)0xff;
	// ### 	iand					temp,	temp,					LL0070
	temp = temp & ll0070;
	// ### 	mfir.y		alphascale,			temp
	alphascale.Y(Math::IntAsFloat(temp));
	// ### 	itof0.y		alphascale,			alphascale
	alphascale.Y((float)Math::FloatAsInt(alphascale.y())/(1<<0));
	// ### 	loi			0x3b808081 
	I = Math::IntAsFloat(0x3b808081);
	// ### 	mul.y			alphascale,			alphascale,				I
	DoFMSETY(alphascale, alphascale * I);
	// ### 	--barrier
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				1
	mkickbufferptr = mkickbufferptr + (unsigned)1;
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layerptr,			layer2,					layer2
	layerptr = layer2 + (unsigned)layer2;
	// ### 	iadd			layerptr,			layerptr,				layer2
	layerptr = layerptr + (unsigned)layer2;
	// ### 	ilw.x			layerType,			133(layerptr)
	layertype = Math::FloatAsInt(vumem[133 + layerptr].x());
	// ### 	iaddiu				LL0071,	vi00,					0xFF
	ll0071 = 0 + (unsigned)0xff;
	// ### 	iand					layerType,	layerType,					LL0071
	layertype = layertype & ll0071;
	// ### 	isubiu				layerType,	layerType,				1
	layertype = layertype - (unsigned)1;
	// ### 	ibeq					layerType,		vi00,					RMP_EnvironmentVerts
	if(layertype == 0) 
	{ 
		rmp_environmentverts(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isubiu				layerType,	layerType,				1
	layertype = layertype - (unsigned)1;
	// ### 	ibeq					layerType,		vi00,					RMP_SpecularVerts
	if(layertype == 0) 
	{ 
		rmp_specularverts(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isubiu				layerType,	layerType,				1
	layertype = layertype - (unsigned)1;
	// ### 	ibeq					layerType,		vi00,					RMP_DistortVerts
	if(layertype == 0)
	{ 
		rmp_distortverts(vumem,xtop,xitop); 
		return; 
	}
	// ### 	lq    mClipToWorld[0], 21+0(vi00)
	mcliptoworld[0].Set(vumem[21+0 + 0]);
	// ### 	lq    mClipToWorld[1], 21+1(vi00)
	mcliptoworld[1].Set(vumem[21+1 + 0]);
	// ### 	lq    mClipToWorld[2], 21+2(vi00)
	mcliptoworld[2].Set(vumem[21+2 + 0]);
	// ### 	lq		mClipToWorld[3], 21+3(vi00)
	mcliptoworld[3].Set(vumem[21+3 + 0]);
	// ### 	lq    mWorldToLocal[0], 13+0(vi00)
	mworldtolocal[0].Set(vumem[13+0 + 0]);
	// ### 	lq    mWorldToLocal[1], 13+1(vi00)
	mworldtolocal[1].Set(vumem[13+1 + 0]);
	// ### 	lq    mWorldToLocal[2], 13+2(vi00)
	mworldtolocal[2].Set(vumem[13+2 + 0]);
	// ### 	lq		mWorldToLocal[3], 13+3(vi00)
	mworldtolocal[3].Set(vumem[13+3 + 0]);
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[0][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[0].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[0][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[0].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[0][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[0].Z());
	// ### 	madd           mClipToLocal[0], mWorldToLocal[3], mClipToWorld[0][w]
	DoFMSET(mcliptolocal[0], acc + mworldtolocal[3] * mcliptoworld[0].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[1][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[1].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[1][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[1].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[1][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[1].Z());
	// ### 	madd           mClipToLocal[1], mWorldToLocal[3], mClipToWorld[1][w]
	DoFMSET(mcliptolocal[1], acc + mworldtolocal[3] * mcliptoworld[1].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[2][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[2].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[2][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[2].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[2][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[2].Z());
	// ### 	madd           mClipToLocal[2], mWorldToLocal[3], mClipToWorld[2][w]
	DoFMSET(mcliptolocal[2], acc + mworldtolocal[3] * mcliptoworld[2].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[3][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[3].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[3][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[3].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[3][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[3].Z());
	// ### 	madd           mClipToLocal[3], mWorldToLocal[3], mClipToWorld[3][w]
	DoFMSET(mcliptolocal[3], acc + mworldtolocal[3] * mcliptoworld[3].W());
	// ### RMP_DecalVerts_Loop320:
	rmp_decalverts_loop320(vumem,xtop,xitop);
}
static void rmp_decalverts_loop320(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				screenSpace,		2(mKickBufferPtr)		:KICKBUFFER
	screenspace.Set(vumem[2 + mkickbufferptr]);
	// ### 	itof4			screenSpace,		screenSpace
	screenspace.Set((float)Math::FloatAsInt(screenspace.x())/(1<<4),(float)Math::FloatAsInt(screenspace.y())/(1<<4),(float)Math::FloatAsInt(screenspace.z())/(1<<4),(float)Math::FloatAsInt(screenspace.w())/(1<<4));
	// ### 	lq				oldtex,				0(mKickBufferPtr)		:KICKBUFFER
	oldtex.Set(vumem[0 + mkickbufferptr]);
	// ### 	div			Q,						vf00[w],					oldtex[z]
	Q = 1.0f / oldtex.Z();
	// ### 	add					acc,			mScreenToClip[3],		VF00[x]
	DoFMSET(acc, mscreentoclip[3] + 0.0f);
	// ### 	madd					acc,			mScreenToClip[0],		screenSpace[x]
	DoFMSET(acc, acc + mscreentoclip[0] * screenspace.X());
	// ### 	madd					acc,			mScreenToClip[1],		screenSpace[y]
	DoFMSET(acc, acc + mscreentoclip[1] * screenspace.Y());
	// ### 	madd					clipSpace,		mScreenToClip[2],		screenSpace[z]
	DoFMSET(clipspace, acc + mscreentoclip[2] * screenspace.Z());
	// ### 	mul.xyzw		clipSpace,			clipSpace,				Q
	DoFMSETXYZW(clipspace, clipspace * Q);
	// ### 	mul					acc,			mClipToLocal[0],		clipSpace[x]
	DoFMSET(acc, mcliptolocal[0] * clipspace.X());
	// ### 	madd					acc,			mClipToLocal[1],		clipSpace[y]
	DoFMSET(acc, acc + mcliptolocal[1] * clipspace.Y());
	// ### 	madd					acc,			mClipToLocal[2],		clipSpace[z]
	DoFMSET(acc, acc + mcliptolocal[2] * clipspace.Z());
	// ### 	madd					localSpace,		mClipToLocal[3],		clipSpace[w]
	DoFMSET(localspace, acc + mcliptolocal[3] * clipspace.W());
	// ### 	add			 		acc,        mTexMatrix[3], 	VF00[x]
	DoFMSET(acc, mtexmatrix[3] + 0.0f);
	// ### 	madd         		acc,        mTexMatrix[0], 	localSpace[x]
	DoFMSET(acc, acc + mtexmatrix[0] * localspace.X());
	// ### 	madd         		acc,        mTexMatrix[1],		localSpace[y]
	DoFMSET(acc, acc + mtexmatrix[1] * localspace.Y());
	// ### 	madd.xyz     		textureSpace, 	mTexMatrix[2],		localSpace[z]
	DoFMSETXYZ(texturespace, acc + mtexmatrix[2] * localspace.Z());
	// ### 	lqi			normal,				(mNormalBufferPtr++)	:NORMALBUFFER
	normal.Set(vumem[mnormalbufferptr++]);
	// ### 	mul.xyz		normal,				normal,					mNormAdj
	DoFMSETXYZ(normal, normal.Diag(mnormadj));
	// ### 	mul.xyz				LL0075,		normal,				normal
	DoFMSETXYZ(ll0075, normal.Diag(normal));
	// ### 	max.xyzw				LL0073,	   vf00,				vf00[w]
	ll0073.Set(1.0f,1.0f,1.0f,1.0f);
	// ### 	add					ACC,			VF00,				LL0075[x]
	DoFMSET(acc, vf0 + ll0075.X());
	// ### 	madd					ACC,			LL0073,				LL0075[y]
	DoFMSET(acc, acc + ll0073 * ll0075.Y());
	// ### 	madd					LL0074,			LL0073,				LL0075[z]
	DoFMSET(ll0074, acc + ll0073 * ll0075.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL0074[x]
	Q = Math::Sqrt(1.0f / ll0074.X());
	// ### 	mul.xyz				normal,			normal,				Q
	DoFMSETXYZ(normal, normal * Q);
	// ### 	add.x			textureSpace,		textureSpace,			normal
	DoFMSETX(texturespace, texturespace + normal);
	// ### 	add.y			textureSpace,		textureSpace,			normal[z]
	DoFMSETY(texturespace, texturespace + normal.Z());
	// ### 	mul.xy		textureSpace,		textureSpace,			oldtex[z]
	DoFMSETXY(texturespace, texturespace * oldtex.Z());
	// ### 	sq.xy			textureSpace,		0(mKickBufferPtr)		:KICKBUFFER
	vumem[0 + mkickbufferptr].XY(texturespace);
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,				temp
//	rgba.Set(Math::IntAsFloat(temp));
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));	// ### 	loi			128.0

	I = 128.0;
	// ### 	mul.w			rgba,				vf00,						I
	DoFMSETW(rgba, vf0 * I);
	// ### 	ilw.y			LL0076,			317(vi00)
	ll0076 = Math::FloatAsInt(vumem[317 + 0].y());
	// ### 	iaddiu				LL0078,	vi00,					3
	ll0078 = 0 + (unsigned)3;
	// ### 	iand					LL0078,		LL0076,				LL0078
	ll0078 = ll0076 & ll0078;
	// ### 	ibeq					LL0078,		VI00,					RF_FadeDone330
	if(ll0078 == 0) 
	{ 
		rf_fadedone330(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				LL007a,	vi00,					2
	ll007a = 0 + (unsigned)2;
	// ### 	iand					LL0079,		LL0076,				LL007a
	ll0079 = ll0076 & ll007a;
	// ### RF_FadeEdges330:
	rf_fadeedges330(vumem,xtop,xitop);
}
static void rf_fadeedges330(Vector4* vumem, short xtop, short xitop)
{

	I = 128.0f;			//PAB added

	// ### 	mul.w			rgba,				normal,				I
	DoFMSETW(rgba, normal * I);
	// ### 	b				RF_FadeDone330
	rf_fadedone330(vumem,xtop,xitop);
	return;
	// ### 	sub.w			LL0077,					vf00,						normal
	DoFMSETW(ll0077, vf0 - normal);
	// ### 	mul.w			rgba,				LL0077,						I
	DoFMSETW(rgba, ll0077 * I);
	// ### RF_FadeDone330:
	rf_fadedone330(vumem,xtop,xitop);
}
static void rf_fadedone330(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.w			rgba,				rgba,					alphascale[y]
	DoFMSETW(rgba, rgba * alphascale.Y());
	// ### 	ftoi0.w		rgba,				rgba
	rgba.W(Math::IntAsFloat((int)(rgba.w()*(1<<0))));
	// ### 	sq.w			rgba,					1(mKickBufferPtr)		:KICKBUFFER
	vumem[1 + mkickbufferptr].W(rgba);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				3
	mkickbufferptr = mkickbufferptr + (unsigned)3;
	// ### 	isubiu				vtxCount,	vtxCount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibne					vtxCount,		vi00,					RMP_DecalVerts_Loop320
	if(vtxcount != 0) 
	{ 
		rmp_decalverts_loop320(vumem,xtop,xitop); 
		return; 
	}
	// ### RMP_DoneWithVerts:
	rmp_donewithverts(vumem,xtop,xitop);
}
static void rmp_donewithverts(Vector4* vumem, short xtop, short xitop)
{
	// ### 	xgkick		mKickBuffer[1]
	XGKICK(vumem, mkickbuffer[1]);
	// ### 	isubiu				LL007b,			buffcount,			1
	ll007b = buffcount - (unsigned)1;
	// ### 	ibeq					LL007b,			vi00,				RMP_SingleBuffer
	if(ll007b == 0) 
	{ 
		rmp_singlebuffer(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				LL007c,	mKickBuffer[1],					0
	ll007c = mkickbuffer[1] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[1],	mKickBuffer[2],					0
	mkickbuffer[1] = mkickbuffer[2] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[2],	LL007c,					0
	mkickbuffer[2] = ll007c + (unsigned)0;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### 	ilw.y			mOtherNormalBuffer, 318(vi00)	:	318
	mothernormalbuffer = Math::FloatAsInt(vumem[318 + 0].y());
	// ### 	isw.x			mOtherNormalBuffer, 318(vi00)	:	318
	vumem[318 + 0].X(Math::IntAsFloat(mothernormalbuffer));
	// ### 	isw.y			mNormalBufferPtr, 318(vi00)		:	318
	vumem[318 + 0].Y(Math::IntAsFloat(mnormalbufferptr));
	// ### 	b				RMP_DoneBufferHandle
	rmp_donebufferhandle(vumem,xtop,xitop);
	return;
}
static void rmp_singlebuffer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### RMP_DoneBufferHandle:
	rmp_donebufferhandle(vumem,xtop,xitop);
}
static void rmp_donebufferhandle(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				currbuff,	currbuff,				1
	currbuff = currbuff - (unsigned)1;
	// ### 	ibgtz			currbuff,			RMP_NextBuffer
	if(currbuff > 0) 
	{ 
		rmp_nextbuffer(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				layer,	layer,				1
	layer = layer + (unsigned)1;
	// ### 	ilw.y			numLayers,			133(vi00)
	numlayers = Math::FloatAsInt(vumem[133 + 0].y());
	// ### 	iaddiu				LL007d,	vi00,					0xFF
	ll007d = 0 + (unsigned)0xff;
	// ### 	iand					numLayers,	numLayers,					LL007d
	numlayers = numlayers & ll007d;
	// ### 	ibne			layer,				numLayers,				RMP_NextLayer	
	if(layer != numlayers)
	{ 
		rmp_nextlayer(vumem,xtop,xitop); 
		return; 
	}
	// ### RMP_DoneWithLayers:
	rmp_donewithlayers(vumem,xtop,xitop);
}
static void rmp_donewithlayers(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				sprite,	vi00,					0
	sprite = 0 + (unsigned)0;
	// ### 	ilw.z			numSprites,			29+1(vi00)
	numsprites = Math::FloatAsInt(vumem[29+1 + 0].z());
	// ### 	iaddiu				LL007e,	vi00,					0xFF
	ll007e = 0 + (unsigned)0xff;
	// ### 	iand					numSprites,	numSprites,					LL007e
	numsprites = numsprites & ll007e;
	// ### 	ibeq			sprite,				numSprites,				RMP_DoneWithSprites
	if(sprite == numsprites) 
	{ 
		rmp_donewithsprites(vumem,xtop,xitop); 
		return; 
	}
}
static void rmp_nextsprite(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iadd			sprite2,				sprite,					sprite
	sprite2 = sprite + (unsigned)sprite;
	// ### 	iadd			sprite4,				sprite2,					sprite2
	sprite4 = sprite2 + (unsigned)sprite2;
	// ### 	iadd			sprite6,				sprite4,					sprite2
	sprite6 = sprite4 + (unsigned)sprite2;
	// ### 	iadd			sprite7,				sprite6,					sprite
	sprite7 = sprite6 + (unsigned)sprite;
	// ### 	lq    mTexMatrix[0], 29+0(sprite7)
	mtexmatrix[0].Set(vumem[29+0 + sprite7]);
	// ### 	lq    mTexMatrix[1], 29+1(sprite7)
	mtexmatrix[1].Set(vumem[29+1 + sprite7]);
	// ### 	lq    mTexMatrix[2], 29+2(sprite7)
	mtexmatrix[2].Set(vumem[29+2 + sprite7]);
	// ### 	lq		mTexMatrix[3], 29+3(sprite7)
	mtexmatrix[3].Set(vumem[29+3 + sprite7]);
	// ### 	lq				sprite[4],			29+4(sprite7)
	spritev[4].Set(vumem[29+4 + sprite7]);
	// ### 	lq				sprite[5],			29+5(sprite7)
	spritev[5].Set(vumem[29+5 + sprite7]);
	// ### 	lq				sprite[6],			29+6(sprite7)
	spritev[6].Set(vumem[29+6 + sprite7]);
	// ### 	iaddiu				layerflags,	vi00,					0
	layerflags = 0 + (unsigned)0;
	// ### 	isw.y			layerFlags,			317(vi00)
	vumem[317 + 0].Y(Math::IntAsFloat(layerflags));
	// ### 	iaddiu				currbuff,	buffcount,					0
	currbuff = buffcount + (unsigned)0;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### RMP_NextSpriteBuffer:
	rmp_nextspritebuffer(vumem,xtop,xitop);
}
static void rmp_nextspritebuffer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	ilw.x			vtxCount,			7(mKickBuffer[1])	:KICKBUFFER
	vtxcount = Math::FloatAsInt(vumem[7 + mkickbuffer[1]].x());
	// ### 	iaddiu				LL007f,	vi00,					0x7fff
	ll007f = 0 + (unsigned)0x7fff;
	// ### 	iand					vtxCount,	vtxCount,					LL007f
	vtxcount = vtxcount & ll007f;
	// ### 	iaddiu				regcount,	vi00,					6
	regcount = 0 + (unsigned)6;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	lq				LL0082,					3(vi00)
	ll0082.Set(vumem[3 + 0]);
	// ### 	mfir.x		LL0082,					regcount
	ll0082.X(Math::IntAsFloat(regcount | 0x80000000));
	// ### 	sqi			LL0082,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(ll0082);
	// ### 	iadd			sprite2,				sprite,					sprite
	sprite2 = sprite + (unsigned)sprite;
	// ### 	iadd			sprite4,				sprite2,					sprite2
	sprite4 = sprite2 + (unsigned)sprite2;
	// ### 	iadd			sprite6,				sprite4,					sprite2
	sprite6 = sprite4 + (unsigned)sprite2;
	// ### 	iadd			sprite7,				sprite6,					sprite
	sprite7 = sprite6 + (unsigned)sprite;
	// ### 	lq    mTexMatrix[0], 29+0(sprite7)
	mtexmatrix[0].Set(vumem[29+0 + sprite7]);
	// ### 	lq    mTexMatrix[1], 29+1(sprite7)
	mtexmatrix[1].Set(vumem[29+1 + sprite7]);
	// ### 	lq    mTexMatrix[2], 29+2(sprite7)
	mtexmatrix[2].Set(vumem[29+2 + sprite7]);
	// ### 	lq		mTexMatrix[3], 29+3(sprite7)
	mtexmatrix[3].Set(vumem[29+3 + sprite7]);
	// ### 	lq				sprite[4],			29+4(sprite7)
	spritev[4].Set(vumem[29+4 + sprite7]);
	// ### 	lq				sprite[5],			29+5(sprite7)
	spritev[5].Set(vumem[29+5 + sprite7]);
	// ### 	lq				sprite[6],			29+6(sprite7)
	spritev[6].Set(vumem[29+6 + sprite7]);
	// ### 	mr32			miptbp2,				sprite[4]
	miptbp2.Set(spritev[4].RotateLeft());
	// ### 	mr32			miptbp2,				miptbp2
	miptbp2.Set(miptbp2.RotateLeft());
	// ### 	move			miptbp1,				sprite[4]
	miptbp1.Set(spritev[4]);
	// ### 	mr32			tex1,					sprite[5]
	tex1.Set(spritev[5].RotateLeft());
	// ### 	mr32			tex1,					tex1
	tex1.Set(tex1.RotateLeft());
	// ### 	move			tex0,					sprite[5]
	tex0.Set(spritev[5]);
	// ### 	move			clamp,				sprite[6]
	clamp.Set(spritev[6]);
	// ### 	mr32			alpha1,				sprite[6]
	alpha1.Set(spritev[6].RotateLeft());
	// ### 	mr32			alpha1,				alpha1
	alpha1.Set(alpha1.RotateLeft());
	// ### 	iaddiu				regnum,	vi00,					0x34
	regnum = 0 + (unsigned)0x34;
	// ### 	mfir.z		miptbp1,				regnum
	miptbp1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x36
	regnum = 0 + (unsigned)0x36;
	// ### 	mfir.z		miptbp2,				regnum
	miptbp2.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x6
	regnum = 0 + (unsigned)0x6;
	// ### 	mfir.z		tex0,					regnum
	tex0.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x14
	regnum = 0 + (unsigned)0x14;
	// ### 	mfir.z		tex1,					regnum
	tex1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x8
	regnum = 0 + (unsigned)0x8;
	// ### 	mfir.z		clamp,				regnum
	clamp.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x42
	regnum = 0 + (unsigned)0x42;
	// ### 	mfir.z		alpha1,				regnum
	alpha1.Z(Math::IntAsFloat(regnum));
	// ### 	sqi.xyz		miptbp1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp1);
	// ### 	sqi.xyz		miptbp2,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp2);
	// ### 	sqi.xyz		tex0,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex0);
	// ### 	sqi.xyz		tex1,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex1);
	// ### 	sqi.xyz		clamp,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(clamp);
	// ### 	sqi.xyz		alpha1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(alpha1);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				1
	mkickbufferptr = mkickbufferptr + (unsigned)1;
	// ### 	lq    mClipToWorld[0], 21+0(vi00)
	mcliptoworld[0].Set(vumem[21+0 + 0]);
	// ### 	lq    mClipToWorld[1], 21+1(vi00)
	mcliptoworld[1].Set(vumem[21+1 + 0]);
	// ### 	lq    mClipToWorld[2], 21+2(vi00)
	mcliptoworld[2].Set(vumem[21+2 + 0]);
	// ### 	lq		mClipToWorld[3], 21+3(vi00)
	mcliptoworld[3].Set(vumem[21+3 + 0]);
	// ### 	lq    mWorldToLocal[0], 13+0(vi00)
	mworldtolocal[0].Set(vumem[13+0 + 0]);
	// ### 	lq    mWorldToLocal[1], 13+1(vi00)
	mworldtolocal[1].Set(vumem[13+1 + 0]);
	// ### 	lq    mWorldToLocal[2], 13+2(vi00)
	mworldtolocal[2].Set(vumem[13+2 + 0]);
	// ### 	lq		mWorldToLocal[3], 13+3(vi00)
	mworldtolocal[3].Set(vumem[13+3 + 0]);
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[0][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[0].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[0][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[0].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[0][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[0].Z());
	// ### 	madd           mClipToLocal[0], mWorldToLocal[3], mClipToWorld[0][w]
	DoFMSET(mcliptolocal[0], acc + mworldtolocal[3] * mcliptoworld[0].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[1][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[1].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[1][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[1].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[1][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[1].Z());
	// ### 	madd           mClipToLocal[1], mWorldToLocal[3], mClipToWorld[1][w]
	DoFMSET(mcliptolocal[1], acc + mworldtolocal[3] * mcliptoworld[1].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[2][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[2].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[2][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[2].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[2][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[2].Z());
	// ### 	madd           mClipToLocal[2], mWorldToLocal[3], mClipToWorld[2][w]
	DoFMSET(mcliptolocal[2], acc + mworldtolocal[3] * mcliptoworld[2].W());
	// ### 	mul            acc,           mWorldToLocal[0], mClipToWorld[3][x]
	DoFMSET(acc, mworldtolocal[0] * mcliptoworld[3].X());
	// ### 	madd           acc,           mWorldToLocal[1], mClipToWorld[3][y]
	DoFMSET(acc, acc + mworldtolocal[1] * mcliptoworld[3].Y());
	// ### 	madd           acc,           mWorldToLocal[2], mClipToWorld[3][z]
	DoFMSET(acc, acc + mworldtolocal[2] * mcliptoworld[3].Z());
	// ### 	madd           mClipToLocal[3], mWorldToLocal[3], mClipToWorld[3][w]
	DoFMSET(mcliptolocal[3], acc + mworldtolocal[3] * mcliptoworld[3].W());
	// ### 	lq				miscqw24,			25(vi00)
	miscqw24.Set(vumem[25 + 0]);
	// ### RMP_DecalVerts_Loop372:
	rmp_decalverts_loop372(vumem,xtop,xitop);
}
static void rmp_decalverts_loop372(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				screenSpace,		2(mKickBufferPtr)		:KICKBUFFER
	screenspace.Set(vumem[2 + mkickbufferptr]);
	// ### 	itof4			screenSpace,		screenSpace
	screenspace.Set((float)Math::FloatAsInt(screenspace.x())/(1<<4),(float)Math::FloatAsInt(screenspace.y())/(1<<4),(float)Math::FloatAsInt(screenspace.z())/(1<<4),(float)Math::FloatAsInt(screenspace.w())/(1<<4));
	// ### 	lq				oldtex,				0(mKickBufferPtr)		:KICKBUFFER
	oldtex.Set(vumem[0 + mkickbufferptr]);
	// ### 	div			Q,						vf00[w],					oldtex[z]
	Q = 1.0f / oldtex.Z();
	// ### 	add					acc,			mScreenToClip[3],		VF00[x]
	DoFMSET(acc, mscreentoclip[3] + 0.0f);
	// ### 	madd					acc,			mScreenToClip[0],		screenSpace[x]
	DoFMSET(acc, acc + mscreentoclip[0] * screenspace.X());
	// ### 	madd					acc,			mScreenToClip[1],		screenSpace[y]
	DoFMSET(acc, acc + mscreentoclip[1] * screenspace.Y());
	// ### 	madd					clipSpace,		mScreenToClip[2],		screenSpace[z]
	DoFMSET(clipspace, acc + mscreentoclip[2] * screenspace.Z());
	// ### 	mul.xyzw		clipSpace,			clipSpace,				Q
	DoFMSETXYZW(clipspace, clipspace * Q);
	// ### 	mul					acc,			mClipToLocal[0],		clipSpace[x]
	DoFMSET(acc, mcliptolocal[0] * clipspace.X());
	// ### 	madd					acc,			mClipToLocal[1],		clipSpace[y]
	DoFMSET(acc, acc + mcliptolocal[1] * clipspace.Y());
	// ### 	madd					acc,			mClipToLocal[2],		clipSpace[z]
	DoFMSET(acc, acc + mcliptolocal[2] * clipspace.Z());
	// ### 	madd					localSpace,		mClipToLocal[3],		clipSpace[w]
	DoFMSET(localspace, acc + mcliptolocal[3] * clipspace.W());
	// ### 	add.xz		localSpace,			localSpace,				miscqw24
	DoFMSETXZ(localspace, localspace + miscqw24);
	// ### 	mr32.y		localSpace,			localSpace
	localspace.Y(localspace.RotateLeft());
	// ### 	move.z		localSpace,			vf00
	localspace.Z(vf0);
	// ### 	add			 		acc,        mTexMatrix[3], 	VF00[x]
	DoFMSET(acc, mtexmatrix[3] + 0.0f);
	// ### 	madd         		acc,        mTexMatrix[0], 	localSpace[x]
	DoFMSET(acc, acc + mtexmatrix[0] * localspace.X());
	// ### 	madd         		acc,        mTexMatrix[1],		localSpace[y]
	DoFMSET(acc, acc + mtexmatrix[1] * localspace.Y());
	// ### 	madd.xyz     		textureSpace, 	mTexMatrix[2],		localSpace[z]
	DoFMSETXYZ(texturespace, acc + mtexmatrix[2] * localspace.Z());
	// ### 	lqi			normal,				(mNormalBufferPtr++)	:NORMALBUFFER
	normal.Set(vumem[mnormalbufferptr++]);
	// ### 	mul.xy		textureSpace,		textureSpace,			oldtex[z]
	DoFMSETXY(texturespace, texturespace * oldtex.Z());
	// ### 	sq.xy			textureSpace,		0(mKickBufferPtr)		:KICKBUFFER
	vumem[0 + mkickbufferptr].XY(texturespace);
	// ### 	sq.xyzw		mTexMatrix[0],		1(mKickBufferPtr)		:KICKBUFFER
	vumem[1 + mkickbufferptr].Set(mtexmatrix[0]);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				3
	mkickbufferptr = mkickbufferptr + (unsigned)3;
	// ### 	isubiu				vtxCount,	vtxCount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibne					vtxCount,		vi00,					RMP_DecalVerts_Loop372
	if(vtxcount != 0)
	{ 
		rmp_decalverts_loop372(vumem,xtop,xitop); 
		return; 
	}
	// ### 	xgkick		mKickBuffer[1]
	XGKICK(vumem, mkickbuffer[1]);
	// ### 	isubiu				LL0084,			buffcount,			1
	ll0084 = buffcount - (unsigned)1;
	// ### 	ibeq					LL0084,			vi00,				RMP_SingleSpriteBuffer
	if(ll0084 == 0) 
	{ 
		rmp_singlespritebuffer(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				LL0085,	mKickBuffer[1],					0
	ll0085 = mkickbuffer[1] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[1],	mKickBuffer[2],					0
	mkickbuffer[1] = mkickbuffer[2] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[2],	LL0085,					0
	mkickbuffer[2] = ll0085 + (unsigned)0;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### 	ilw.y			mOtherNormalBuffer, 318(vi00)	:	318
	mothernormalbuffer = Math::FloatAsInt(vumem[318 + 0].y());
	// ### 	isw.x			mOtherNormalBuffer, 318(vi00)	:	318
	vumem[318 + 0].X(Math::IntAsFloat(mothernormalbuffer));
	// ### 	isw.y			mNormalBufferPtr, 318(vi00)		:	318
	vumem[318 + 0].Y(Math::IntAsFloat(mnormalbufferptr));
	// ### 	b				RMP_DoneBufferHandleSprite
	rmp_donebufferhandlesprite(vumem,xtop,xitop);return;
	// ### RMP_SingleSpriteBuffer:
	rmp_singlespritebuffer(vumem,xtop,xitop);
}
static void rmp_singlespritebuffer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				noptag,	vi00,					317
	noptag = 0 + (unsigned)317;
	// ### 	xgkick		noptag
	XGKICK(vumem, noptag);
	// ### RMP_DoneBufferHandleSprite:
	rmp_donebufferhandlesprite(vumem,xtop,xitop);
}
static void rmp_donebufferhandlesprite(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isubiu				currbuff,	currbuff,				1
	currbuff = currbuff - (unsigned)1;
	// ### 	ibgtz			currbuff,			RMP_NextSpriteBuffer
	if(currbuff > 0) 
	{ 
		rmp_nextspritebuffer(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				sprite,	sprite,				1
	sprite = sprite + (unsigned)1;
	// ### 	ilw.z			numSprites,			29+1(vi00)
	numsprites = Math::FloatAsInt(vumem[29+1 + 0].z());
	// ### 	iaddiu				LL0086,	vi00,					0xFF
	ll0086 = 0 + (unsigned)0xff;
	// ### 	iand					numSprites,	numSprites,					LL0086
	numsprites = numsprites & ll0086;
	// ### 	ibne			sprite,				numSprites,				RMP_NextSprite
	if(sprite != numsprites) 
	{ 
		rmp_nextsprite(vumem,xtop,xitop);
		return; 
	}
	// ### RMP_DoneWithSprites:
	rmp_donewithsprites(vumem,xtop,xitop);
}
static void rmp_donewithsprites(Vector4* vumem, short xtop, short xitop)
{
	// ### 	jr				retaddr
	return;
}
static void renderfan(Vector4* vumem, short xtop, short xitop){
	// ### 	lq				vtx,					3(mKickBuffer[0])		:KICKBUFFER
	vtxv.Set(vumem[3 + mkickbuffer[0]]);
	// ### 	sq				vtx,					0(mKickBufferPtr)		:KICKBUFFER
	vumem[0 + mkickbufferptr].Set(vtxv);
	// ### 	lq				vtx,					4(mKickBuffer[0])		:KICKBUFFER
	vtxv.Set(vumem[4 + mkickbuffer[0]]);
	// ### 	sq				vtx,					1(mKickBufferPtr)		:KICKBUFFER
	vumem[1 + mkickbufferptr].Set(vtxv);
	// ### 	lq				vtx,					5(mKickBuffer[0])		:KICKBUFFER
	vtxv.Set(vumem[5 + mkickbuffer[0]]);
	// ### 	sq				vtx,					2(mKickBufferPtr)		:KICKBUFFER
	vumem[2 + mkickbufferptr].Set(vtxv);
	// ### 	iaddiu				mKickBufferPtr,	mKickBufferPtr,				3
	mkickbufferptr = mkickbufferptr + (unsigned)3;
	// ### 	isub			size,					mKickBufferPtr,		mKickBuffer[0]
	size = mkickbufferptr - (unsigned)mkickbuffer[0];
	// ### 	mfir			fsize,				size
//	fsize.Set(Math::IntAsFloat(size));
	fsize.Set(Math::IntAsFloat(size),Math::IntAsFloat(size),Math::IntAsFloat(size),Math::IntAsFloat(size));	// ### 	loi			128.0
	// ### 	loi			0x3EAAAAAB		  
	I = Math::IntAsFloat(0x3eaaaaab);
	// ### 	itof0			fsize,				fsize
	fsize.Set((float)Math::FloatAsInt(fsize.x())/(1<<0),(float)Math::FloatAsInt(fsize.y())/(1<<0),(float)Math::FloatAsInt(fsize.z())/(1<<0),(float)Math::FloatAsInt(fsize.w())/(1<<0));
	// ### 	mul			fsize,				fsize,					I
	DoFMSET(fsize, fsize * I);
	// ### 	ftoi0			fsize,				fsize
	fsize.Set(Math::IntAsFloat((int)(fsize.x()*(1<<0))), Math::IntAsFloat((int)(fsize.y()*(1<<0))), Math::IntAsFloat((int)(fsize.z()*(1<<0))), Math::IntAsFloat((int)(fsize.w()*(1<<0))));
	// ### 	mtir			vtxcount,			fsize[x]
	vtxcount = (unsigned short)Math::FloatAsInt(fsize.X());
	// ### 	iaddiu				maxverts,	vi00,					64
	maxverts = 0 + (unsigned)64;
	// ### 	isub					LL0088,			vtxcount,			maxverts
	ll0088 = vtxcount - (unsigned)maxverts;
	// ### 	ibltz					LL0088,			assertlt396
	if(ll0088 < 0) 
	{ 
		assertlt396(vumem,xtop,xitop);
		return; 
	}
	// ### 	.raw
	// ### 	nop nop
	// ### 	.endraw
	// ### assertlt396:
	assertlt396(vumem,xtop,xitop);
}
static void assertlt396(Vector4* vumem, short xtop, short xitop)
{
	// ### RF_DARSRequestScissor:
	rf_darsrequestscissor(vumem,xtop,xitop);
}
static void rf_darsrequestscissor(Vector4* vumem, short xtop, short xitop)
{
	//PAB
	// changed as per Tyler comments. to call skipclip instead
	rf_skipclip(vumem,xtop,xitop);
	return;			//?


	// should never get here....



	// ### 	lq LL0089, 0(mKickBuffer[0])
	ll0089.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL0089, 0(mKickBufferPtr)
	vumem[0 + mkickbufferptr].Set(ll0089);
	// ### 	lq LL0089, 1(mKickBuffer[0])
	ll0089.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL0089, 1(mKickBufferPtr)
	vumem[1 + mkickbufferptr].Set(ll0089);
	// ### 	lq LL0089, 2(mKickBuffer[0])
	ll0089.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL0089, 2(mKickBufferPtr)
	vumem[2 + mkickbufferptr].Set(ll0089);
	// ### 	mfir.x	 LL008a, mKickBuffer[2]
	ll008a.X(Math::IntAsFloat(mkickbuffer[2]));
	// ### 	mfir.y	 LL008a, quad
	ll008a.Y(Math::IntAsFloat(quad));
	// ### 	mfir.z	 LL008a, depth
	ll008a.Z(Math::IntAsFloat(depth));
	// ### 	sqd.xyz LL008a, (--Stack)
	vumem[--stack].XYZ(ll008a);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL008c, mKickBuffer[0]
	ll008c.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL008c, mKickBuffer[1]
	ll008c.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL008c, (--Stack)
	vumem[--stack].XY(ll008c);
	// ### 	mini.x			RotVec[0],	   vf00,				vf00[x]
	rotvec[0].X(0.0f);
	// ### 	mini.x			RotVec[1],	   vf00,				vf00[x]
	rotvec[1].X(0.0f);
	// ### 	max.x				RotVec[2],		vf00,				vf00[w]
	rotvec[2].X(1.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x800
	curclipflg = 0 + (unsigned)0x800;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x020
	nxtclipflg = 0 + (unsigned)0x020;
	// ### 	sub.x				PlaneSign,		vf00,				vf00[w]
	DoFMSETX(planesign, - 1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop402:
	scissorloop402(vumem,xtop,xitop);
}
static void scissorloop402(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop402
	if(vtxcount > 0) 
	{ 
		scissorloop402(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL008f, (Stack++)
	ll008f.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL008f[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll008f.X());
	// ### 	mtir	 mKickBuffer[0], LL008f[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll008f.Y());
	// ### 	isubiu				LL008b,  vtxcount,		2
	ll008b = vtxcount - (unsigned)2;
	// ### 	iblez					LL008b,  RF_EmptyFan
	if(ll008b <= 0)
	{ 
		rf_emptyfan(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				Work[0],		mKickBuffer[1],		0
	work[0] = mkickbuffer[1] + (unsigned)0;
	// ### 	lq LL0091, 0(mKickBuffer[0])
	ll0091.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL0091, 0(Work[1])
	vumem[0 + work[1]].Set(ll0091);
	// ### 	lq LL0091, 1(mKickBuffer[0])
	ll0091.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL0091, 1(Work[1])
	vumem[1 + work[1]].Set(ll0091);
	// ### 	lq LL0091, 2(mKickBuffer[0])
	ll0091.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL0091, 2(Work[1])
	vumem[2 + work[1]].Set(ll0091);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL0093, mKickBuffer[0]
	ll0093.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL0093, mKickBuffer[1]
	ll0093.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL0093, (--Stack)
	vumem[--stack].XY(ll0093);
	// ### 	mini.x			RotVec[0],	   vf00,				vf00[x]
	rotvec[0].X(0.0f);
	// ### 	mini.x			RotVec[1],	   vf00,				vf00[x]
	rotvec[1].X(0.0f);
	// ### 	max.x				RotVec[2],		vf00,				vf00[w]
	rotvec[2].X(1.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x400
	curclipflg = 0 + (unsigned)0x400;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x010
	nxtclipflg = 0 + (unsigned)0x010;
	// ### 	max.x				PlaneSign,		vf00,				vf00[w]
	planesign.X(1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop415:
	scissorloop415(vumem,xtop,xitop);
}
static void scissorloop415(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop415
	if(vtxcount > 0) 
	{ 
		scissorloop415(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL0095, (Stack++)
	ll0095.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL0095[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll0095.X());
	// ### 	mtir	 mKickBuffer[0], LL0095[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll0095.Y());
	// ### 	isubiu				LL0092,  vtxcount,		2
	ll0092 = vtxcount - (unsigned)2;
	// ### 	iblez					LL0092,  RF_EmptyFan
	if(ll0092 <= 0) 
	{ 
		rf_emptyfan(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				Work[0],		mKickBuffer[1],		0
	work[0] = mkickbuffer[1] + (unsigned)0;
	// ### 	lq LL0097, 0(mKickBuffer[0])
	ll0097.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL0097, 0(Work[1])
	vumem[0 + work[1]].Set(ll0097);
	// ### 	lq LL0097, 1(mKickBuffer[0])
	ll0097.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL0097, 1(Work[1])
	vumem[1 + work[1]].Set(ll0097);
	// ### 	lq LL0097, 2(mKickBuffer[0])
	ll0097.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL0097, 2(Work[1])
	vumem[2 + work[1]].Set(ll0097);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL0099, mKickBuffer[0]
	ll0099.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL0099, mKickBuffer[1]
	ll0099.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL0099, (--Stack)
	vumem[--stack].XY(ll0099);
	// ### 	max.x				RotVec[0],		vf00,				vf00[w]
	rotvec[0].X(1.0f);
	// ### 	mini.x			RotVec[1],	   vf00,				vf00[x]
	rotvec[1].X(0.0f);
	// ### 	mini.x			RotVec[2],	   vf00,				vf00[x]
	rotvec[2].X(0.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x080
	curclipflg = 0 + (unsigned)0x080;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x002
	nxtclipflg = 0 + (unsigned)0x002;
	// ### 	sub.x				PlaneSign,		vf00,				vf00[w]
	DoFMSETX(planesign, - 1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop427:
	scissorloop427(vumem,xtop,xitop);
}
static void scissorloop427(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop427
	if(vtxcount > 0) 
	{
		scissorloop427(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL009c, (Stack++)
	ll009c.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL009c[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll009c.X());
	// ### 	mtir	 mKickBuffer[0], LL009c[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll009c.Y());
	// ### 	isubiu				LL0098,  vtxcount,		2
	ll0098 = vtxcount - (unsigned)2;
	// ### 	iblez					LL0098,  RF_EmptyFan
	if(ll0098 <= 0) 
	{
		rf_emptyfan(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				Work[0],		mKickBuffer[1],		0
	work[0] = mkickbuffer[1] + (unsigned)0;
	// ### 	lq LL009e, 0(mKickBuffer[0])
	ll009e.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL009e, 0(Work[1])
	vumem[0 + work[1]].Set(ll009e);
	// ### 	lq LL009e, 1(mKickBuffer[0])
	ll009e.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL009e, 1(Work[1])
	vumem[1 + work[1]].Set(ll009e);
	// ### 	lq LL009e, 2(mKickBuffer[0])
	ll009e.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL009e, 2(Work[1])
	vumem[2 + work[1]].Set(ll009e);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL00a0, mKickBuffer[0]
	ll00a0.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL00a0, mKickBuffer[1]
	ll00a0.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL00a0, (--Stack)
	vumem[--stack].XY(ll00a0);
	// ### 	max.x				RotVec[0],		vf00,				vf00[w]
	rotvec[0].X(1.0f);
	// ### 	mini.x			RotVec[1],	   vf00,				vf00[x]
	rotvec[1].X(0.0f);
	// ### 	mini.x			RotVec[2],	   vf00,				vf00[x]
	rotvec[2].X(0.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x040
	curclipflg = 0 + (unsigned)0x040;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x001
	nxtclipflg = 0 + (unsigned)0x001;
	// ### 	max.x				PlaneSign,		vf00,				vf00[w]
	planesign.X(1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop440:
	scissorloop440(vumem,xtop,xitop);
}
static void scissorloop440(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop440
	if(vtxcount > 0) 
	{ 
		scissorloop440(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL00a2, (Stack++)
	ll00a2.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL00a2[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll00a2.X());
	// ### 	mtir	 mKickBuffer[0], LL00a2[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll00a2.Y());
	// ### 	isubiu				LL009f,  vtxcount,		2
	ll009f = vtxcount - (unsigned)2;
	// ### 	iblez					LL009f,  RF_EmptyFan
	if(ll009f <= 0) 
	{
		rf_emptyfan(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				Work[0],		mKickBuffer[1],		0
	work[0] = mkickbuffer[1] + (unsigned)0;
	// ### 	lq LL00a4, 0(mKickBuffer[0])
	ll00a4.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL00a4, 0(Work[1])
	vumem[0 + work[1]].Set(ll00a4);
	// ### 	lq LL00a4, 1(mKickBuffer[0])
	ll00a4.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL00a4, 1(Work[1])
	vumem[1 + work[1]].Set(ll00a4);
	// ### 	lq LL00a4, 2(mKickBuffer[0])
	ll00a4.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL00a4, 2(Work[1])
	vumem[2 + work[1]].Set(ll00a4);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL00a6, mKickBuffer[0]
	ll00a6.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL00a6, mKickBuffer[1]
	ll00a6.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL00a6, (--Stack)
	vumem[--stack].XY(ll00a6);
	// ### 	mini.x			RotVec[0],	   vf00,				vf00[x]
	rotvec[0].X(0.0f);
	// ### 	max.x				RotVec[1],		vf00,				vf00[w]
	rotvec[1].X(1.0f);
	// ### 	mini.x			RotVec[2],	   vf00,				vf00[x]
	rotvec[2].X(0.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x200
	curclipflg = 0 + (unsigned)0x200;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x008
	nxtclipflg = 0 + (unsigned)0x008;
	// ### 	sub.x				PlaneSign,		vf00,				vf00[w]
	DoFMSETX(planesign, - 1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop452:
	scissorloop452(vumem,xtop,xitop);
}
static void scissorloop452(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop452
	if(vtxcount > 0) 
	{
		scissorloop452(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL00a9, (Stack++)
	ll00a9.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL00a9[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll00a9.X());
	// ### 	mtir	 mKickBuffer[0], LL00a9[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll00a9.Y());
	// ### 	isubiu				LL00a5,  vtxcount,		2
	ll00a5 = vtxcount - (unsigned)2;
	// ### 	iblez					LL00a5,  RF_EmptyFan
	if(ll00a5 <= 0)
	{ 
		rf_emptyfan(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				Work[0],		mKickBuffer[1],		0
	work[0] = mkickbuffer[1] + (unsigned)0;
	// ### 	lq LL00ab, 0(mKickBuffer[0])
	ll00ab.Set(vumem[0 + mkickbuffer[0]]);
	// ### 	sq LL00ab, 0(Work[1])
	vumem[0 + work[1]].Set(ll00ab);
	// ### 	lq LL00ab, 1(mKickBuffer[0])
	ll00ab.Set(vumem[1 + mkickbuffer[0]]);
	// ### 	sq LL00ab, 1(Work[1])
	vumem[1 + work[1]].Set(ll00ab);
	// ### 	lq LL00ab, 2(mKickBuffer[0])
	ll00ab.Set(vumem[2 + mkickbuffer[0]]);
	// ### 	sq LL00ab, 2(Work[1])
	vumem[2 + work[1]].Set(ll00ab);
	// ### 	iaddiu				Work[0],		mKickBuffer[0],		0
	work[0] = mkickbuffer[0] + (unsigned)0;
	// ### 	iaddiu				Work[1],		mKickBuffer[1],		0
	work[1] = mkickbuffer[1] + (unsigned)0;
	// ### 	mfir.x	 LL00ad, mKickBuffer[0]
	ll00ad.X(Math::IntAsFloat(mkickbuffer[0]));
	// ### 	mfir.y	 LL00ad, mKickBuffer[1]
	ll00ad.Y(Math::IntAsFloat(mkickbuffer[1]));
	// ### 	sqd.xy LL00ad, (--Stack)
	vumem[--stack].XY(ll00ad);
	// ### 	mini.x			RotVec[0],	   vf00,				vf00[x]
	rotvec[0].X(0.0f);
	// ### 	max.x				RotVec[1],		vf00,				vf00[w]
	rotvec[1].X(1.0f);
	// ### 	mini.x			RotVec[2],	   vf00,				vf00[x]
	rotvec[2].X(0.0f);
	// ### 	iaddiu				CurClipFlg,	VI00,				0x100
	curclipflg = 0 + (unsigned)0x100;
	// ### 	iaddiu				NxtClipFlg,	VI00,				0x004
	nxtclipflg = 0 + (unsigned)0x004;
	// ### 	max.x				PlaneSign,		vf00,				vf00[w]
	planesign.X(1.0f);
	// ### 	iaddiu				NewCount,	VI00,				0
	newcount = 0 + (unsigned)0;
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### ScissorLoop465:
	scissorloop465(vumem,xtop,xitop);
}
static void scissorloop465(Vector4* vumem, short xtop, short xitop)
{
	// ### 	--barrier
	// ### 	isubiu				vtxcount,	vtxcount,		1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	--barrier
	// ### 	bal					ScissorReturn, _ScissorInterpolationSCISSOR_LAYER_COUNT
	_scissorinterpolationscissor_layer_count(vumem,xtop,xitop);
	// ### 	ibgtz					vtxcount,	ScissorLoop465
	if(vtxcount > 0) 
	{
		scissorloop465(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				vtxcount,	NewCount,		0
	vtxcount = newcount + (unsigned)0;
	// ### 	lqi.xyzw LL00af, (Stack++)
	ll00af.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[1], LL00af[x]
	mkickbuffer[1] = (unsigned short)Math::FloatAsInt(ll00af.X());
	// ### 	mtir	 mKickBuffer[0], LL00af[y]
	mkickbuffer[0] = (unsigned short)Math::FloatAsInt(ll00af.Y());
	// ### 	isubiu				LL00ac,  vtxcount,		2
	ll00ac = vtxcount - (unsigned)2;
	// ### 	iblez					LL00ac,  RF_EmptyFan
	if(ll00ac <= 0) 
	{
		rf_emptyfan(vumem,xtop,xitop);
		return; 
	}
	// ### 	lqi.xyzw LL00b1, (Stack++)
	ll00b1.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[2], LL00b1[x]
	mkickbuffer[2] = (unsigned short)Math::FloatAsInt(ll00b1.X());
	// ### 	mtir	 quad, LL00b1[y]
	quad = (unsigned short)Math::FloatAsInt(ll00b1.Y());
	// ### 	mtir	 depth, LL00b1[z]
	depth = (unsigned short)Math::FloatAsInt(ll00b1.Z());
	// ### 	iaddiu				maxverts,	vi00,					64
	maxverts = 0 + (unsigned)64;
	// ### 	isub					LL00b4,			vtxcount,			maxverts
	ll00b4 = vtxcount - (unsigned)maxverts;
	// ### 	ibltz					LL00b4,			assertlt478
	if(ll00b4 < 0) 
	{ 
		assertlt478(vumem,xtop,xitop); 
		return; 
	}
	// ### 	.raw
	// ### 	nop nop
	// ### 	.endraw
	// ### assertlt478:
	assertlt478(vumem,xtop,xitop);
}
static void assertlt478(Vector4* vumem, short xtop, short xitop)
{
	// ### RF_SkipClip:
	rf_skipclip(vumem,xtop,xitop);
}
static void rf_skipclip(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq    mClipToScreen[0], 9+0(vi00)
	mcliptoscreen[0].Set(vumem[9+0 + 0]);
	// ### 	lq    mClipToScreen[1], 9+1(vi00)
	mcliptoscreen[1].Set(vumem[9+1 + 0]);
	// ### 	lq    mClipToScreen[2], 9+2(vi00)
	mcliptoscreen[2].Set(vumem[9+2 + 0]);
	// ### 	lq		mClipToScreen[3], 9+3(vi00)
	mcliptoscreen[3].Set(vumem[9+3 + 0]);
	// ### 	iaddiu				layer,	vi00,					0
	layer = 0 + (unsigned)0;
	// ### 	iaddiu				regcount,	vi00,					6
	regcount = 0 + (unsigned)6;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	lq				LL00b7,					3(vi00)
	ll00b7.Set(vumem[3 + 0]);
	// ### 	mfir.x		LL00b7,					regcount
	ll00b7.X(Math::IntAsFloat(regcount | 0x80000000));
	// ### 	sqi			LL00b7,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(ll00b7);
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layer4,				layer2,					layer2
	layer4 = layer2 + (unsigned)layer2;
	// ### 	iadd			layer6,				layer4,					layer2
	layer6 = layer4 + (unsigned)layer2;
	// ### 	lq				layer[0],			133+0(layer6)
	layerv[0].Set(vumem[133+0 + layer6]);
	// ### 	lq				layer[1],			133+1(layer6)
	layerv[1].Set(vumem[133+1 + layer6]);
	// ### 	lq				layer[2],			133+2(layer6)
	layerv[2].Set(vumem[133+2 + layer6]);
	// ### 	lq				layer[3],			133+3(layer6)
	layerv[3].Set(vumem[133+3 + layer6]);
	// ### 	lq				layer[4],			133+4(layer6)
	layerv[4].Set(vumem[133+4 + layer6]);
	// ### 	mr32			miptbp2,				layer[1]
	miptbp2.Set(layerv[1].RotateLeft());
	// ### 	mr32			miptbp2,				miptbp2
	miptbp2.Set(miptbp2.RotateLeft());
	// ### 	move			miptbp1,				layer[1]
	miptbp1.Set(layerv[1]);
	// ### 	mr32			tex1,					layer[2]
	tex1.Set(layerv[2].RotateLeft());
	// ### 	mr32			tex1,					tex1
	tex1.Set(tex1.RotateLeft());
	// ### 	move			tex0,					layer[2]
	tex0.Set(layerv[2]);
	// ### 	move			clamp,				layer[3]
	clamp.Set(layerv[3]);
	// ### 	mr32			alpha1,				layer[0]
	alpha1.Set(layerv[0].RotateLeft());
	// ### 	mr32			alpha1,				alpha1
	alpha1.Set(alpha1.RotateLeft());
	// ### 	iaddiu				regnum,	vi00,					0x34
	regnum = 0 + (unsigned)0x34;
	// ### 	mfir.z		miptbp1,				regnum
	miptbp1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x36
	regnum = 0 + (unsigned)0x36;
	// ### 	mfir.z		miptbp2,				regnum
	miptbp2.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x6
	regnum = 0 + (unsigned)0x6;
	// ### 	mfir.z		tex0,					regnum
	tex0.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x14
	regnum = 0 + (unsigned)0x14;
	// ### 	mfir.z		tex1,					regnum
	tex1.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x8
	regnum = 0 + (unsigned)0x8;
	// ### 	mfir.z		clamp,				regnum
	clamp.Z(Math::IntAsFloat(regnum));
	// ### 	iaddiu				regnum,	vi00,					0x42
	regnum = 0 + (unsigned)0x42;
	// ### 	mfir.z		alpha1,				regnum
	alpha1.Z(Math::IntAsFloat(regnum));
	// ### 	sqi.xyz		miptbp1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp1);
	// ### 	sqi.xyz		miptbp2,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(miptbp2);
	// ### 	sqi.xyz		tex0,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex0);
	// ### 	sqi.xyz		tex1,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(tex1);
	// ### 	sqi.xyz		clamp,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(clamp);
	// ### 	sqi.xyz		alpha1,				(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].XYZ(alpha1);
	// ### 	mtir			temp,					alpha1[y]
	temp = (unsigned short)Math::FloatAsInt(alpha1.Y());
	// ### 	iaddiu				LL00b8,	vi00,					0xFF
	ll00b8 = 0 + (unsigned)0xff;
	// ### 	iand					temp,	temp,					LL00b8
	temp = temp & ll00b8;
	// ### 	mfir.y		alphascale,			temp
	alphascale.Y(Math::IntAsFloat(temp));
	// ### 	itof0.y		alphascale,			alphascale
	alphascale.Y((float)Math::FloatAsInt(alphascale.y())/(1<<0));
	// ### 	loi			0x3b808081 
	I = Math::IntAsFloat(0x3b808081);
	// ### 	mul.y			alphascale,			alphascale,				I
	DoFMSETY(alphascale, alphascale * I);
	// ### 	--barrier
	// ### 	lq				LL00bb,					1(vi00)
	ll00bb.Set(vumem[1 + 0]);
	// ### 	iaddiu				LL00b9,	vi00,					1
	ll00b9 = 0 + (unsigned)1;
	// ### 	iaddiu				LL00b9,	LL00b9,				0x7fff
	ll00b9 = ll00b9 + (unsigned)0x7fff;
	// ### 	ior			LL00ba,				vtxcount,				LL00b9
	ll00ba = vtxcount | ll00b9;
	// ### 	mfir.x		LL00bb,					LL00ba
	ll00bb.X(Math::IntAsFloat(ll00ba));
	// ### 	sqi			LL00bb,					(mKickBufferPtr++)	:KICKBUFFER
	vumem[mkickbufferptr++].Set(ll00bb);
	// ### 	iaddiu				InputPtr,	mKickBuffer[0],					0
	inputptr = mkickbuffer[0] + (unsigned)0;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,					temp
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));	// ### 	loi			128.0
	// ### 	iadd			layer2,				layer,					layer
	layer2 = layer + (unsigned)layer;
	// ### 	iadd			layerptr,			layer2,					layer2
	layerptr = layer2 + (unsigned)layer2;
	// ### 	iadd			layerptr,			layerptr,				layer2
	layerptr = layerptr + (unsigned)layer2;
	// ### 	ilw.x			layerType,			133(layerptr)
	layertype = Math::FloatAsInt(vumem[133 + layerptr].x());
	// ### 	iaddiu				LL00bc,	vi00,					0xFF
	ll00bc = 0 + (unsigned)0xff;
	// ### 	iand					layerType,	layerType,					LL00bc
	layertype = layertype & ll00bc;
	// ### 	isubiu				layerType,	layerType,				3
	layertype = layertype - (unsigned)3;
	// ### 	ibeq					layerType,		vi00,					RF_DistortVtx
	if(layertype == 0) 
	{ 
		rf_distortvtx(vumem,xtop,xitop);
		return; 
	}
	// ### RF_NextVtx:
	rf_nextvtx(vumem,xtop,xitop);
}
static void rf_nextvtx(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				vtx,					0(InputPtr)
	vtxv.Set(vumem[0 + inputptr]);
	// ### 	lq				st,					1(InputPtr)
	st.Set(vumem[1 + inputptr]);
	// ### 	lq				normal,				2(InputPtr)
	normal.Set(vumem[2 + inputptr]);
	// ### 	iaddiu				InputPtr,	InputPtr,				3
	inputptr = inputptr + (unsigned)3;
	// ### 	mul.xyz		lnormal,				normal,					mNormAdj
	DoFMSETXYZ(lnormal, normal.Diag(mnormadj));
	// ### 	mul.xyz				LL00bf,		lnormal,				lnormal
	DoFMSETXYZ(ll00bf, lnormal.Diag(lnormal));
	// ### 	max.xyzw				LL00bd,	   vf00,				vf00[w]
	ll00bd.Set(1.0f,1.0f,1.0f,1.0f);
	// ### 	add					ACC,			VF00,				LL00bf[x]
	DoFMSET(acc, vf0 + ll00bf.X());
	// ### 	madd					ACC,			LL00bd,				LL00bf[y]
	DoFMSET(acc, acc + ll00bd * ll00bf.Y());
	// ### 	madd					LL00be,			LL00bd,				LL00bf[z]
	DoFMSET(ll00be, acc + ll00bd * ll00bf.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL00be[x]
	Q = Math::Sqrt(1.0f / ll00be.X());
	// ### 	mul.xyz				lnormal,			lnormal,				Q
	DoFMSETXYZ(lnormal, lnormal * Q);
	// ### 	add			 		acc,        mTexMatrix[3], 	VF00[x]
	DoFMSET(acc, mtexmatrix[3] + 0.0f);
	// ### 	madd         		acc,        mTexMatrix[0], 	st[x]
	DoFMSET(acc, acc + mtexmatrix[0] * st.X());
	// ### 	madd         		acc,        mTexMatrix[1],		st[y]
	DoFMSET(acc, acc + mtexmatrix[1] * st.Y());
	// ### 	madd.xyz     		st, 	mTexMatrix[2],		st[z]
	DoFMSETXYZ(st, acc + mtexmatrix[2] * st.Z());
	// ### 	add.x			st,					st,						lnormal
	DoFMSETX(st, st + lnormal);
	// ### 	add.y			st,					st,						lnormal[z]
	DoFMSETY(st, st + lnormal.Z());
	// ### 	ilw.x			flags0,				4(vi00)
	flags0 = Math::FloatAsInt(vumem[4 + 0].x());
	// ### 	iaddiu				LL00c0,	vi00,					16
	ll00c0 = 0 + (unsigned)16;
	// ### 	iand					LL00c0,		flags0,				LL00c0
	ll00c0 = flags0 & ll00c0;
	// ### 	ibeq					LL00c0,		VI00,					RF_DontRandColor
	if(ll00c0 == 0) 
	{
		rf_dontrandcolor(vumem,xtop,xitop); 
		return; 
	}
	// ### 	rnext.x		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.X(R);
	// ### 	rnext.y		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.Y(R);
	// ### 	rnext.z		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.Z(R);
	// ### 	ftoi15.xyz	rgba,					rgba
	rgba.XYZ(Math::IntAsFloat((int)(rgba.x()*(1<<15))), Math::IntAsFloat((int)(rgba.y()*(1<<15))), Math::IntAsFloat((int)(rgba.z()*(1<<15))));
	// ### 	b				RF_FadeDone
	rf_fadedone(vumem,xtop,xitop);
	return;
}
static void rf_dontrandcolor(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,				temp
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));	// ### 	loi			128.0
//	rgba.Set(Math::IntAsFloat(temp));
	// ### 	loi			128.0
	I = 128.0;
	// ### 	mul.w			rgba,				vf00,						I
	DoFMSETW(rgba, vf0 * I);
	// ### 	ilw.y			LL00c1,			317(vi00)
	ll00c1 = Math::FloatAsInt(vumem[317 + 0].y());
	// ### 	iaddiu				LL00c3,	vi00,					3
	ll00c3 = 0 + (unsigned)3;
	// ### 	iand					LL00c3,		LL00c1,				LL00c3
	ll00c3 = ll00c1 & ll00c3;
	// ### 	ibeq					LL00c3,		VI00,					RF_FadeDone510
	if(ll00c3 == 0)
	{
		rf_fadedone510(vumem,xtop,xitop); 
		return; 
	}
	// ### 	iaddiu				LL00c5,	vi00,					2
	ll00c5 = 0 + (unsigned)2;
	// ### 	iand					LL00c4,		LL00c1,				LL00c5
	ll00c4 = ll00c1 & ll00c5;
	// ### RF_FadeEdges510:
	rf_fadeedges510(vumem,xtop,xitop);
}
static void rf_fadeedges510(Vector4* vumem, short xtop, short xitop)
{
	I = 128.0f;			// PAB

	// ### 	mul.w			rgba,				normal,				I
	DoFMSETW(rgba, normal * I);
	// ### 	b				RF_FadeDone510
	rf_fadedone510(vumem,xtop,xitop);
	return;

	// ### 	sub.w			LL00c2,					vf00,						normal
	DoFMSETW(ll00c2, vf0 - normal);
	// ### 	mul.w			rgba,				LL00c2,						I
	DoFMSETW(rgba, ll00c2 * I);
	// ### RF_FadeDone510:
	rf_fadedone510(vumem,xtop,xitop);
}
static void rf_fadedone510(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.w			rgba,				rgba,					alphascale[y]
	DoFMSETW(rgba, rgba * alphascale.Y());
	// ### 	ftoi0.w		rgba,				rgba
	rgba.W(Math::IntAsFloat((int)(rgba.w()*(1<<0))));
	// ### RF_FadeDone:
	rf_fadedone(vumem,xtop,xitop);
}
static void rf_fadedone(Vector4* vumem, short xtop, short xitop)
{
	// ### 	div			Q,						vf00[w],					vtx[w]
	Q = 1.0f / vtxv.W();
	// ### 	mini.w			destvtx,	   vf00,				vf00[x]
	destvtx.W(0.0f);
	// ### 	mul.xyz		destvtx,				vtx,						Q
	DoFMSETXYZ(destvtx, vtxv * Q);
	// ### 	add			 		acc,        mClipToScreen[3], 	VF00[x]
	DoFMSET(acc, mcliptoscreen[3] + 0.0f);
	// ### 	madd         		acc,        mClipToScreen[0], 	destvtx[x]
	DoFMSET(acc, acc + mcliptoscreen[0] * destvtx.X());
	// ### 	madd         		acc,        mClipToScreen[1],		destvtx[y]
	DoFMSET(acc, acc + mcliptoscreen[1] * destvtx.Y());
	// ### 	madd.xyz     		destvtx, 	mClipToScreen[2],		destvtx[z]
	DoFMSETXYZ(destvtx, acc + mcliptoscreen[2] * destvtx.Z());
	// ### 	ftoi4.xyz	destvtx,				destvtx
	destvtx.XYZ(Math::IntAsFloat((int)(destvtx.x()*(1<<4))), Math::IntAsFloat((int)(destvtx.y()*(1<<4))), Math::IntAsFloat((int)(destvtx.z()*(1<<4))));
	// ### 	max.z				st,		vf00,				vf00[w]
	st.Z(1.0f);
	// ### 	mul.xyz		st,					st,						Q
	DoFMSETXYZ(st, st * Q);
	// ### 	sqi.xyz		st,					(mKickBufferPtr++)
	vumem[mkickbufferptr++].XYZ(st);
	// ### 	sqi			rgba,					(mKickBufferPtr++)
	vumem[mkickbufferptr++].Set(rgba);
	// ### 	sqi			destvtx,				(mKickBufferPtr++)
	vumem[mkickbufferptr++].Set(destvtx);
	// ### 	sqi			normal,				(mNormalBufferPtr++)
	vumem[mnormalbufferptr++].Set(normal);
	// ### 	isubiu				vtxcount,	vtxcount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibgtz			vtxcount,			RF_NextVtx
	if(vtxcount > 0)
	{ 
		rf_nextvtx(vumem,xtop,xitop); 
		return; 
	}
	// ### 	b				RF_VertsReady
	rf_vertsready(vumem,xtop,xitop);
	return;
}
static void rf_distortvtx(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lq				vtx,					0(InputPtr)
	vtxv.Set(vumem[0 + inputptr]);
	// ### 	lq				st,					1(InputPtr)
	st.Set(vumem[1 + inputptr]);
	// ### 	lq				normal,				2(InputPtr)
	normal.Set(vumem[2 + inputptr]);
	// ### 	iaddiu				InputPtr,	InputPtr,				3
	inputptr = inputptr + (unsigned)3;
	// ### 	mul.xyz		lnormal,				normal,					mNormAdj
	DoFMSETXYZ(lnormal, normal.Diag(mnormadj));
	// ### 	mul.xyz				LL00c8,		lnormal,				lnormal
	DoFMSETXYZ(ll00c8, lnormal.Diag(lnormal));
	// ### 	max.xyzw				LL00c6,	   vf00,				vf00[w]
	ll00c6.Set(1.0f,1.0f,1.0f,1.0f);
	// ### 	add					ACC,			VF00,				LL00c8[x]
	DoFMSET(acc, vf0 + ll00c8.X());
	// ### 	madd					ACC,			LL00c6,				LL00c8[y]
	DoFMSET(acc, acc + ll00c6 * ll00c8.Y());
	// ### 	madd					LL00c7,			LL00c6,				LL00c8[z]
	DoFMSET(ll00c7, acc + ll00c6 * ll00c8.Z());
	// ### 	rsqrt					Q,				VF00[w],			LL00c7[x]
	Q = Math::Sqrt(1.0f / ll00c7.X());
	// ### 	mul.xyz				lnormal,			lnormal,				Q
	DoFMSETXYZ(lnormal, lnormal * Q);
	// ### 	ilw.x			flags0,				4(vi00)
	flags0 = Math::FloatAsInt(vumem[4 + 0].x());
	// ### 	iaddiu				LL00c9,	vi00,					16
	ll00c9 = 0 + (unsigned)16;
	// ### 	iand					LL00c9,		flags0,				LL00c9
	ll00c9 = flags0 & ll00c9;
	// ### 	ibeq					LL00c9,		VI00,					RF_DontRandColor2
	if(ll00c9 == 0) 
	{ 
		rf_dontrandcolor2(vumem,xtop,xitop); 
		return; 
	}
	// ### 	rnext.x		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.X(R);
	// ### 	rnext.y		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.Y(R);
	// ### 	rnext.z		rgba,					R
	R = Math::IntAsFloat((rand() & 0x007FFFFF) | 0x78000000);
	rgba.Z(R);
	// ### 	ftoi15.xyz	rgba,					rgba
	rgba.XYZ(Math::IntAsFloat((int)(rgba.x()*(1<<15))), Math::IntAsFloat((int)(rgba.y()*(1<<15))), Math::IntAsFloat((int)(rgba.z()*(1<<15))));
	// ### 	b				RF_FadeDone2
	rf_fadedone2(vumem,xtop,xitop);
	return;
}
static void rf_dontrandcolor2(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				temp,	vi00,					0x80
	temp = 0 + (unsigned)0x80;
	// ### 	mfir			rgba,				temp
//	rgba.Set(Math::IntAsFloat(temp));
	rgba.Set(Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp),Math::IntAsFloat(temp));	// ### 	loi			128.0
	// ### 	loi			128.0
	I = 128.0;
	// ### 	mul.w			rgba,				vf00,						I
	DoFMSETW(rgba, vf0 * I);
	// ### 	ilw.y			LL00ca,			317(vi00)
	ll00ca = Math::FloatAsInt(vumem[317 + 0].y());
	// ### 	iaddiu				LL00cc,	vi00,					3
	ll00cc = 0 + (unsigned)3;
	// ### 	iand					LL00cc,		LL00ca,				LL00cc
	ll00cc = ll00ca & ll00cc;
	// ### 	ibeq					LL00cc,		VI00,					RF_FadeDone526
	if(ll00cc == 0)
	{ 
		rf_fadedone526(vumem,xtop,xitop);
		return; 
	}
	// ### 	iaddiu				LL00ce,	vi00,					2
	ll00ce = 0 + (unsigned)2;
	// ### 	iand					LL00cd,		LL00ca,				LL00ce
	ll00cd = ll00ca & ll00ce;
	// ### RF_FadeEdges526:
	rf_fadeedges526(vumem,xtop,xitop);
}
static void rf_fadeedges526(Vector4* vumem, short xtop, short xitop)
{
	I = 128.0;		// PAB
	// ### 	mul.w			rgba,				normal,				I		
	DoFMSETW(rgba, normal * I);
	// ### 	b				RF_FadeDone526
	rf_fadedone526(vumem,xtop,xitop);
	return;

	
	// ### 	sub.w			LL00cb,					vf00,						normal
	DoFMSETW(ll00cb, vf0 - normal);
	// ### 	mul.w			rgba,				LL00cb,						I
	DoFMSETW(rgba, ll00cb * I);
	// ### RF_FadeDone526:
	rf_fadedone526(vumem,xtop,xitop);
}
static void rf_fadedone526(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.w			rgba,				rgba,					alphascale[y]
	DoFMSETW(rgba, rgba * alphascale.Y());
	// ### 	ftoi0.w		rgba,				rgba
	rgba.W(Math::IntAsFloat((int)(rgba.w()*(1<<0))));
	// ### RF_FadeDone2:
	rf_fadedone2(vumem,xtop,xitop);
}
static void rf_fadedone2(Vector4* vumem, short xtop, short xitop)
{
	// ### 	add.xz		st,					st,						lnormal
	DoFMSETXZ(st, st + lnormal);
	// ### 	add					acc,			mLocalToClip[3],		VF00[x]
	DoFMSET(acc, mlocaltoclip[3] + 0.0f);
	// ### 	madd					acc,			mLocalToClip[0],		st[x]
	DoFMSET(acc, acc + mlocaltoclip[0] * st.X());
	// ### 	madd					acc,			mLocalToClip[1],		st[y]
	DoFMSET(acc, acc + mlocaltoclip[1] * st.Y());
	// ### 	madd					st,		mLocalToClip[2],		st[z]
	DoFMSET(st, acc + mlocaltoclip[2] * st.Z());
	// ### 	div			Q,						vf00[w],					st[w]
	Q = 1.0f / st.W();
	// ### 	mul.xyz		st,					st,						Q
	DoFMSETXYZ(st, st * Q);
	// ### 	loi 0.5
	I = 0.5;
	// ### 	mul.xyz		st,					st,						I
	DoFMSETXYZ(st, st * I);
	// ### 	add.xyz		st,					st,						I
	DoFMSETXYZ(st, st + I);
	// ### 	max.xyz		st,					st,						vf00[x]
	st.XYZ(Vector4::Max(st, Vector4(0.0f,0.0f,0.0f,0.0f)));
	// ### 	mini.xyz		st,					st,						vf00[w]
	st.XYZ(Vector4::Min(st, Vector4(1.0f,1.0f,1.0f,1.0f)));
	// ### 	loi 0x3F600000					  
	I = Math::IntAsFloat(0x3f600000);
	// ### 	mul.y			st,					st,						I
	DoFMSETY(st, st * I);
	// ### 	div			Q,						vf00[w],					vtx[w]
	Q = 1.0f / vtxv.W();
	// ### 	mini.w			destvtx,	   vf00,				vf00[x]
	destvtx.W(0.0f);
	// ### 	mul.xyz		destvtx,				vtx,						Q
	DoFMSETXYZ(destvtx, vtxv * Q);
	// ### 	add			 		acc,        mClipToScreen[3], 	VF00[x]
	DoFMSET(acc, mcliptoscreen[3] + 0.0f);
	// ### 	madd         		acc,        mClipToScreen[0], 	destvtx[x]
	DoFMSET(acc, acc + mcliptoscreen[0] * destvtx.X());
	// ### 	madd         		acc,        mClipToScreen[1],		destvtx[y]
	DoFMSET(acc, acc + mcliptoscreen[1] * destvtx.Y());
	// ### 	madd.xyz     		destvtx, 	mClipToScreen[2],		destvtx[z]
	DoFMSETXYZ(destvtx, acc + mcliptoscreen[2] * destvtx.Z());
	// ### 	ftoi4.xyz	destvtx,				destvtx
	destvtx.XYZ(Math::IntAsFloat((int)(destvtx.x()*(1<<4))), Math::IntAsFloat((int)(destvtx.y()*(1<<4))), Math::IntAsFloat((int)(destvtx.z()*(1<<4))));
	// ### 	max.z				st,		vf00,				vf00[w]
	st.Z(1.0f);
	// ### 	mul.xyz		st,					st,						Q
	DoFMSETXYZ(st, st * Q);
	// ### 	sqi.xyz		st,					(mKickBufferPtr++)
	vumem[mkickbufferptr++].XYZ(st);
	// ### 	sqi			rgba,					(mKickBufferPtr++)
	vumem[mkickbufferptr++].Set(rgba);
	// ### 	sqi			destvtx,				(mKickBufferPtr++)
	vumem[mkickbufferptr++].Set(destvtx);
	// ### 	sqi			normal,				(mNormalBufferPtr++)
	vumem[mnormalbufferptr++].Set(normal);
	// ### 	isubiu				vtxcount,	vtxcount,				1
	vtxcount = vtxcount - (unsigned)1;
	// ### 	ibgtz			vtxcount,			RF_DistortVtx
	if(vtxcount > 0) 
	{ 
		rf_distortvtx(vumem,xtop,xitop); 
		return; 
	}
	// ### 	b				RF_VertsReady
	rf_vertsready(vumem,xtop,xitop);
	return;
}
static void rf_vertsready(Vector4* vumem, short xtop, short xitop)
{
	// ### 	xgkick		mKickBuffer[1]
	XGKICK(vumem, mkickbuffer[1]);
	// ### 	iaddiu				LL00cf,	mKickBuffer[1],					0
	ll00cf = mkickbuffer[1] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[1],	mKickBuffer[2],					0
	mkickbuffer[1] = mkickbuffer[2] + (unsigned)0;
	// ### 	iaddiu				mKickBuffer[2],	LL00cf,					0
	mkickbuffer[2] = ll00cf + (unsigned)0;
	// ### 	iaddiu				mKickBufferPtr,	mKickBuffer[1],					0
	mkickbufferptr = mkickbuffer[1] + (unsigned)0;
	// ### 	ilw.x			mNormalBufferPtr,	318(vi00)		:	318
	mnormalbufferptr = Math::FloatAsInt(vumem[318 + 0].x());
	// ### 	ilw.y			mOtherNormalBuffer, 318(vi00)	:	318
	mothernormalbuffer = Math::FloatAsInt(vumem[318 + 0].y());
	// ### 	isw.x			mOtherNormalBuffer, 318(vi00)	:	318
	vumem[318 + 0].X(Math::IntAsFloat(mothernormalbuffer));
	// ### 	isw.y			mNormalBufferPtr, 318(vi00)		:	318
	vumem[318 + 0].Y(Math::IntAsFloat(mnormalbufferptr));
	// ### 	ilw.w			mOtherKickedBuff,	317(vi00)	:317
	motherkickedbuff = Math::FloatAsInt(vumem[317 + 0].w());
	// ### 	ibeq					mOtherKickedBuff,		vi00,					RF_NoOtherBuffer
	if(motherkickedbuff == 0) 
	{ 
		rf_nootherbuffer(vumem,xtop,xitop); 
		return; 
	}
	// ### 	isw.w			vi00,					317(vi00)	:317
	vumem[317 + 0].W(0.0f);
	// ### 	iaddiu				buffcount,	vi00,					2
	buffcount = 0 + (unsigned)2;
	// ### 	b				RenderMultiPass
	rendermultipass(vumem,xtop,xitop);
	return;
}
static void rf_nootherbuffer(Vector4* vumem, short xtop, short xitop)
{
	// ### 	isw.w			mKickBuffer[2],	317(vi00)	:317
	vumem[317 + 0].W(Math::IntAsFloat(mkickbuffer[2]));
	// ### 	jr				retaddr
	return;
}
static void rf_emptyfan(Vector4* vumem, short xtop, short xitop)
{
	// ### 	lqi.xyzw LL00d0, (Stack++)
	ll00d0.Set(vumem[stack++]);
	// ### 	mtir	 mKickBuffer[2], LL00d0[x]
	mkickbuffer[2] = (unsigned short)Math::FloatAsInt(ll00d0.X());
	// ### 	mtir	 quad, LL00d0[y]
	quad = (unsigned short)Math::FloatAsInt(ll00d0.Y());
	// ### 	mtir	 depth, LL00d0[z]
	depth = (unsigned short)Math::FloatAsInt(ll00d0.Z());
	// ### 	jr				retaddr
	return;
}
static void _scissorinterpolationscissor_layer_count(Vector4* vumem, short xtop, short xitop){
	// ### 	move					currvtx,						nextvtx
	currvtx.Set(nextvtx);
	// ### 	move					currtex[0],		nexttex[0]
	currtex[0].Set(nexttex[0]);
	// ### 	move					currtex[1],		nexttex[1]
	currtex[1].Set(nexttex[1]);
	// ### 	lqi.xyzw nextvtx, (Work[0]++)
	nextvtx.Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[0], (Work[0]++)
	nexttex[0].Set(vumem[work[0]++]);
	// ### 	lqi.xyzw nexttex[1], (Work[0]++)
	nexttex[1].Set(vumem[work[0]++]);
	// ### 	clipw.xyz			currvtx,	currvtx
	Clip(currvtx,currvtx);
	// ### 	clipw.xyz			nextvtx,	nextvtx
	Clip(nextvtx,nextvtx);
	// ### 	fcget					vi01
	vi1 = FC;
	// ### 	iand					LL00d2,	vi01,				CurClipFlg
	ll00d2 = vi1 & curclipflg;
	// ### 	ibeq					LL00d2,	vi00,				CurrInside546
	if(ll00d2 == 0) 
	{ 
		currinside546(vumem,xtop,xitop);
		return; 
	}
	// ### CurrOutside546:
	curroutside546(vumem,xtop,xitop);
}
static void curroutside546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iand					LL00d2,	vi01,				NxtClipFlg
	ll00d2 = vi1 & nxtclipflg;
	// ### 	ibeq					LL00d2,	vi00,				CONextIn546
	if(ll00d2 == 0) 
	{
		conextin546(vumem,xtop,xitop); 
		return;
	}
	// ### CONextOut546:
	conextout546(vumem,xtop,xitop);
}
static void conextout546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	b						ScissorInterpolationEnd546
	scissorinterpolationend546(vumem,xtop,xitop);
	return;
}
static void conextin546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.w					LL00d5,		currvtx,		PlaneSign[x] 
	DoFMSETW(ll00d5, currvtx * planesign.X());
	// ### 	sub					LL00d5,		currvtx,		LL00d5[w]
	DoFMSET(ll00d5, currvtx - ll00d5.W());
	// ### 	mul.w					LL00d6,		nextvtx,		PlaneSign[x]
	DoFMSETW(ll00d6, nextvtx * planesign.X());
	// ### 	sub					LL00d6,		nextvtx,		LL00d6[w]
	DoFMSET(ll00d6, nextvtx - ll00d6.W());
	// ### 	mul.x					acc,			RotVec[0],		LL00d5[x]
	DoFMSETX(acc, rotvec[0] * ll00d5.X());
	// ### 	madd.x				acc,			RotVec[1],		LL00d5[y]
	DoFMSETX(acc, acc + rotvec[1] * ll00d5.Y());
	// ### 	madd.x				LL00d5,		RotVec[2],		LL00d5[z]
	DoFMSETX(ll00d5, acc + rotvec[2] * ll00d5.Z());
	// ### 	mul.x					acc,			RotVec[0],		LL00d6[x]
	DoFMSETX(acc, rotvec[0] * ll00d6.X());
	// ### 	madd.x				acc,			RotVec[1],		LL00d6[y]
	DoFMSETX(acc, acc + rotvec[1] * ll00d6.Y());
	// ### 	madd.x				LL00d6,		RotVec[2],		LL00d6[z]
	DoFMSETX(ll00d6, acc + rotvec[2] * ll00d6.Z());
	// ### 	sub.x					LL00d7,	LL00d6,			LL00d5
	DoFMSETX(ll00d7, ll00d6 - ll00d5);
	// ### 	div					Q,				LL00d5[x],		LL00d7[x]
	Q = ll00d5.X() / ll00d7.X();
	// ### 	add.x					LL00d8,		VF00,				Q
	DoFMSETX(ll00d8, + Q);
	// ### 	abs.x					LL00d8,		LL00d8			
	ll00d8.X(ll00d8.Abs());
	// ### 	sub					ll00d3vtx,	nextvtx,		currvtx
	DoFMSET(ll00d3vtx, nextvtx - currvtx);
	// ### 	mul					ll00d3vtx,	ll00d3vtx,		LL00d8[x]
	DoFMSET(ll00d3vtx, ll00d3vtx * ll00d8.X());
	// ### 	add					ll00d3vtx,	ll00d3vtx,		currvtx
	DoFMSET(ll00d3vtx, ll00d3vtx + currvtx);
	// ### 	sub					ll00d3tex[0],		nexttex[0], currtex[0]
	DoFMSET(ll00d3tex[0], nexttex[0] - currtex[0]);
	// ### 	mul					ll00d3tex[0],		ll00d3tex[0],  LL00d8[x]
	DoFMSET(ll00d3tex[0], ll00d3tex[0] * ll00d8.X());
	// ### 	add					ll00d3tex[0],		ll00d3tex[0],  currtex[0]
	DoFMSET(ll00d3tex[0], ll00d3tex[0] + currtex[0]);
	// ### 	sub					ll00d3tex[1],		nexttex[1], currtex[1]
	DoFMSET(ll00d3tex[1], nexttex[1] - currtex[1]);
	// ### 	mul					ll00d3tex[1],		ll00d3tex[1],  LL00d8[x]
	DoFMSET(ll00d3tex[1], ll00d3tex[1] * ll00d8.X());
	// ### 	add					ll00d3tex[1],		ll00d3tex[1],  currtex[1]
	DoFMSET(ll00d3tex[1], ll00d3tex[1] + currtex[1]);
	// ### 	sqi.xyzw ll00d3vtx, (Work[1]++)
	vumem[work[1]++].Set(ll00d3vtx);
	// ### 	sqi.xyzw ll00d3tex[0], (Work[1]++)
	vumem[work[1]++].Set(ll00d3tex[0]);
	// ### 	sqi.xyzw ll00d3tex[1], (Work[1]++)
	vumem[work[1]++].Set(ll00d3tex[1]);
	// ### 	iaddiu				NewCount,	NewCount,		1
	newcount = newcount + (unsigned)1;
	// ### 	b						ScissorInterpolationEnd546
	scissorinterpolationend546(vumem,xtop,xitop);
	return;
}
static void currinside546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	sqi.xyzw currvtx, (Work[1]++)
	vumem[work[1]++].Set(currvtx);
	// ### 	sqi.xyzw currtex[0], (Work[1]++)
	vumem[work[1]++].Set(currtex[0]);
	// ### 	sqi.xyzw currtex[1], (Work[1]++)
	vumem[work[1]++].Set(currtex[1]);
	// ### 	iand					LL00d2,	vi01,				NxtClipFlg
	ll00d2 = vi1 & nxtclipflg;
	// ### 	ibeq					LL00d2,	vi00,				CINextIn546
	if(ll00d2 == 0)
	{ 
		cinextin546(vumem,xtop,xitop);
		return; 
	}
	// ### CINextOut546:
	cinextout546(vumem,xtop,xitop);
}
static void cinextout546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	mul.w					LL00db,		nextvtx,		PlaneSign[x] 
	DoFMSETW(ll00db, nextvtx * planesign.X());
	// ### 	sub					LL00db,		nextvtx,		LL00db[w]
	DoFMSET(ll00db, nextvtx - ll00db.W());
	// ### 	mul.w					LL00dc,		currvtx,		PlaneSign[x]
	DoFMSETW(ll00dc, currvtx * planesign.X());
	// ### 	sub					LL00dc,		currvtx,		LL00dc[w]
	DoFMSET(ll00dc, currvtx - ll00dc.W());
	// ### 	mul.x					acc,			RotVec[0],		LL00db[x]
	DoFMSETX(acc, rotvec[0] * ll00db.X());
	// ### 	madd.x				acc,			RotVec[1],		LL00db[y]
	DoFMSETX(acc, acc + rotvec[1] * ll00db.Y());
	// ### 	madd.x				LL00db,		RotVec[2],		LL00db[z]
	DoFMSETX(ll00db, acc + rotvec[2] * ll00db.Z());
	// ### 	mul.x					acc,			RotVec[0],		LL00dc[x]
	DoFMSETX(acc, rotvec[0] * ll00dc.X());
	// ### 	madd.x				acc,			RotVec[1],		LL00dc[y]
	DoFMSETX(acc, acc + rotvec[1] * ll00dc.Y());
	// ### 	madd.x				LL00dc,		RotVec[2],		LL00dc[z]
	DoFMSETX(ll00dc, acc + rotvec[2] * ll00dc.Z());
	// ### 	sub.x					LL00dd,	LL00dc,			LL00db
	DoFMSETX(ll00dd, ll00dc - ll00db);
	// ### 	div					Q,				LL00db[x],		LL00dd[x]
	Q = ll00db.X() / ll00dd.X();
	// ### 	add.x					LL00de,		VF00,				Q
	DoFMSETX(ll00de, + Q);
	// ### 	abs.x					LL00de,		LL00de			
	ll00de.X(ll00de.Abs());
	// ### 	sub					ll00d3vtx,	currvtx,		nextvtx
	DoFMSET(ll00d3vtx, currvtx - nextvtx);
	// ### 	mul					ll00d3vtx,	ll00d3vtx,		LL00de[x]
	DoFMSET(ll00d3vtx, ll00d3vtx * ll00de.X());
	// ### 	add					ll00d3vtx,	ll00d3vtx,		nextvtx
	DoFMSET(ll00d3vtx, ll00d3vtx + nextvtx);
	// ### 	sub					ll00d3tex[0],		currtex[0], nexttex[0]
	DoFMSET(ll00d3tex[0], currtex[0] - nexttex[0]);
	// ### 	mul					ll00d3tex[0],		ll00d3tex[0],  LL00de[x]
	DoFMSET(ll00d3tex[0], ll00d3tex[0] * ll00de.X());
	// ### 	add					ll00d3tex[0],		ll00d3tex[0],  nexttex[0]
	DoFMSET(ll00d3tex[0], ll00d3tex[0] + nexttex[0]);
	// ### 	sub					ll00d3tex[1],		currtex[1], nexttex[1]
	DoFMSET(ll00d3tex[1], currtex[1] - nexttex[1]);
	// ### 	mul					ll00d3tex[1],		ll00d3tex[1],  LL00de[x]
	DoFMSET(ll00d3tex[1], ll00d3tex[1] * ll00de.X());
	// ### 	add					ll00d3tex[1],		ll00d3tex[1],  nexttex[1]
	DoFMSET(ll00d3tex[1], ll00d3tex[1] + nexttex[1]);
	// ### 	sqi.xyzw ll00d3vtx, (Work[1]++)
	vumem[work[1]++].Set(ll00d3vtx);
	// ### 	sqi.xyzw ll00d3tex[0], (Work[1]++)
	vumem[work[1]++].Set(ll00d3tex[0]);
	// ### 	sqi.xyzw ll00d3tex[1], (Work[1]++)
	vumem[work[1]++].Set(ll00d3tex[1]);
	// ### 	iaddiu				NewCount,	NewCount,		2
	newcount = newcount + (unsigned)2;
	// ### 	b						ScissorInterpolationEnd546
	scissorinterpolationend546(vumem,xtop,xitop);
	return;
}
static void cinextin546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	iaddiu				NewCount,	NewCount,		1
	newcount = newcount + (unsigned)1;
	// ### ScissorInterpolationEnd546:
	scissorinterpolationend546(vumem,xtop,xitop);
}
static void scissorinterpolationend546(Vector4* vumem, short xtop, short xitop)
{
	// ### 	jr						ScissorReturn
	return;
}

#endif	// vu_implementation
#endif	// ps2
